# ================
# SOFTWARE LICENSE
# ================

# The MIT License (MIT)

# Copyright (c) 2022 Yutaka Sawai (Varipon)

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ==============================================================
# LICENSE FOR CONTENT PROCEDURALLY GENERATED USING THIS SOFTWARE
# ==============================================================

# All content procedurally generated by this software and its permutations
# are licensed under Creative Commons Attribution By 3.0:

# https://creativecommons.org/licenses/by/3.0/


#!/usr/bin/python

import bpy
from bpy import *

import mathutils
import math
from mathutils import *
from math import *


class Formula:

    def __init__(self, P, A, J, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 
        
        # joint number
        self.J = J

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)


    def configMovement(self, P, A, J, a, b, y, o):

        mat_a = [0 for i in range(4)] # Joint α matrix
        mat_b = [0 for i in range(self.J)] # Joint β matrix
        mat_y = [0 for i in range(self.J)] # Joint γ matrix
        mat_o = [0 for i in range(self.J)] # Joint δ matrix

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        a[0] = mathutils.Euler((-A - E + (D * 0.5), -A - (D * 0.5), 0.0), 'XYZ')
        print ("a0 =", a[0])
        mat_a[0] = Matrix.Translation(a[0])

        a[3] = mathutils.Euler((0-a[0].x, 0-a[0].y, 0-a[0].z), 'XYZ')
        print ("a3 =", a[3])
        mat_a[3] = Matrix.Translation(a[3]) 

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        mat_y[1] = Matrix.Translation(y[1])

### pattern A

        b[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y + (A * 2), 0.0), 'XYZ')
        print ("b2 =", b[2])
        mat_b[2] = Matrix.Translation(b[2])

        b[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (A * 2), 0.0), 'XYZ')
        print ("b3 =", b[3])
        mat_b[3] = Matrix.Translation(b[3])
        
        y[2] = mathutils.Euler((a[0].x + E, a[0].y, 0.0), 'XYZ')
        print ("y2 =", y[2])
        mat_y[2] = Matrix.Translation(y[2])

        y[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (D * 0.5), 0.0), 'XYZ')
        print ("y3 =", y[3])
        mat_y[3] = Matrix.Translation(y[3])

        o[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y - (A * 2), 0.0), 'XYZ')
        print ("o2 =", o[2])
        mat_o[2] = Matrix.Translation(o[2])
        
        o[3] = mathutils.Euler((a[0].x + E - (D * 0.5) - (A * 2), a[0].y - (D * 0.5) - (A * 2), 0.0), 'XYZ')
        print ("o3 =", o[3])
        mat_o[3] = Matrix.Translation(o[3])

### pattern A end

        org_rot_mat = Matrix.Rotation(math.radians(0), 4, 'Z')

        # define the rotation
        rot_mat = Matrix.Rotation(math.radians(-45), 4, 'Z')   

        for j in range(2, J - 2):

            mat_y[j + 2] = mat_a[0] @ org_rot_mat @ rot_mat @ mat_a[3] @ mat_y[j]

#            obj.matrix_world = mat_y[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_y[j + 2].decompose()
            y[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("y"+str(j + 2)+" = ", y[j + 2], rot, sca)

            mat_b[j + 2] = mat_a[0] @ org_rot_mat @ rot_mat @ mat_a[3] @ mat_b[j]
            
#            obj.matrix_world = mat_b[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_b[j + 2].decompose()
            b[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("b"+str(j + 2)+" = ", b[j + 2], rot, sca)

            mat_o[j + 2] = mat_a[0] @ org_rot_mat @ rot_mat @ mat_a[3] @ mat_o[j]
            
#            obj.matrix_world = mat_o[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_o[j + 2].decompose()
            o[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("o"+str(j + 2)+" = ", o[j + 2], rot, sca)


    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-2):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')
        

    def configRotation(self, rig, interval, frame_start, frame_end, start, end):

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        # key insert 
        keyframe_insert_interval = interval

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(start) 
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_start)

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(end)
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_end)

        for curve in bpy.context.active_object.animation_data.action.fcurves:
            cycles = curve.modifiers.new(type='CYCLES')
            cycles.mode_before = 'REPEAT_OFFSET'
            cycles.mode_after = 'REPEAT_OFFSET'

            for keyframe in curve.keyframe_points:
                keyframe.interpolation = 'LINEAR'

        bpy.ops.object.mode_set(mode='OBJECT')


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    def constructLink(self, A, J, helicity, rig, move, part):

        # Move and rotate the tip bone in pose mode
        bpy.context.view_layer.objects.active = rig 

        Y = 1.1838*A

        for n in rig.pose.bones:
            if n.name != "o" + str(J-2) + "b" + str(J-1):
                # we can get the object from the pose bone
                obj = n.id_data
                matrix_final = obj.matrix_world @ n.matrix

                # Create armature and object
                lnk = bpy.data.armatures.new(n.name[:len(n.name)]+'.data.' + helicity)
                lnk_rig = bpy.data.objects.new(n.name[:len(n.name)]+'.link.' + helicity, lnk)
                lnk_rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')

                # rig.show_in_front = True
                lnk.show_names = True
                lnk.display_type = 'STICK'

                bpy.data.collections['link'].objects.link(lnk_rig)
                bpy.context.view_layer.objects.active = lnk_rig
                bpy.context.view_layer.update()

                # Create bones

                # mode='EDIT'
                bpy.ops.object.editmode_toggle()
    
                link = lnk.edit_bones.new(n.name[:len(n.name)])
                link.head = (0.0, 0.0, 0.0)
                link.tail = (0.0, Y, 0.0)

                link_head = lnk.edit_bones.new('head')
                link_head.head = (0.0, 0.0, 0.1)
                link_head.tail = (0.0, 0.0, 0.0)
                link_head.parent = link
                link_head.use_inherit_scale = False

                link_tail = lnk.edit_bones.new('tail')
                link_tail.head = (0.0, Y, 0.0)
                link_tail.tail = (0.0, Y, -0.1)
                link_tail.parent = link
                link_tail.use_inherit_scale = False

                bpy.ops.object.mode_set(mode='OBJECT')

                ob = bpy.data.objects[n.name[:len(n.name)]+'.mesh.' + move + '.' + part +'.' + helicity]
                ob.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
    
                # Give mesh object an armature modifier, using vertex groups but
                # not envelopes
                mod = ob.modifiers.new('MyRigModif', 'ARMATURE')
                mod.object = lnk_rig
                mod.use_bone_envelopes = False
                mod.use_vertex_groups = True

                # Bone constraints. Armature must be in pose mode.
                bpy.ops.object.mode_set(mode='POSE')
 
                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_LOCATION')
                cns.name = 'Copy_Location'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_ROTATION')
                cns.name = 'Copy_Rotation'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # StretchTo constraint Mid -> Tip with influence 0.5
                cns1 = pBase.constraints.new('STRETCH_TO')
                cns1.name = 'Stretch'
                cns1.target = rig
                cns1.subtarget = n.name[:len(n.name)]
                cns1.head_tail = 1
                cns1.rest_length = Y
                cns1.influence = 1
                cns1.keep_axis = 'PLANE_Z'
                cns1.volume = 'NO_VOLUME'

                bpy.ops.object.mode_set(mode='OBJECT')


class Finger(Formula):
    
    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, y2, y3, y4, y5):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end
 
        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end
        
        # phalanx length
        self.y2 = y2
        self.y3 = y3
        self.y4 = y4
        self.y5 = y5

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o,
            self.y2, self.y3, self.y4, self.y5)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)


    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, y2, y3, y4, y5):
        
        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        y[2] = y2
        print ("y2 =", y[2])

        y[3] = y3
        print ("y3 =", y[3])

        y[4] = y4
        print ("y4 =", y[4])

        y[5] = y5
        print ("y5 =", y[5])


        b[2] = mathutils.Euler((y[2].x+0.10012, y[2].y+0.170067, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler((y[3].x-0.12471, y[3].y-0.03395, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        b[4] = mathutils.Euler((y[4].x-0.11426, y[4].y-0.03342, 0.0), 'XYZ')
        print ("b4 =", b[4])


        o[2] = mathutils.Euler((y[2].x+0.09016, y[2].y+0.142795, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler((y[3].x+0.07367, y[3].y+0.09711, 0.0), 'XYZ')
        print ("o3 =", o[3])

        o[4] = mathutils.Euler((y[4].x+0.00899, y[4].y+0.03297, 0.0), 'XYZ')
        print ("o4 =", o[4])
        
        
class Wrist(Formula):

    J = 3 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
        disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master        
        self.setParent(self.helicity, self.move, self.rig, 
            self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, -(0.173028/0.351)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler((-A, (-5.09454/0.351)*A, 0.0), 'XYZ')
        print ("o1 =", o[1])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = by[1][1]
   
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b1y1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        

class Arm(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master        
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((4.95121/0.421838)*A, (-4.25872/0.421838)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((4.72825/0.421838)*A, (-4.95019/0.421838)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        b[4] = mathutils.Euler(((6.768483/0.4)*A, (-2.571618/0.4)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])
        
        y[2] = mathutils.Euler(((4.10753/0.421838)*A, (-5.1024/0.421838)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((4.392454/0.4)*A, (-5.033079/0.4)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((3.56863/0.421838)*A, (-3.96908/0.421838)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((4.079091/0.4)*A, (-5.305482/0.4)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        o[4] = mathutils.Euler(((8.488379/0.4)*A, (-1.411269/0.4)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])
        
        y[4] = mathutils.Euler(((8.581694/0.4)*A, (-1.518615/0.4)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])
        
        y[5] = mathutils.Euler(((8.789228/0.4)*A, (-1.338207/0.4)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b4y4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        
    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                if n == 3:
                    obj_joint = bpy.data.objects["joint.blue.o3b4.arm"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.blue.001"].copy()
                
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Arm2(Arm):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A*0.8, self.J, self.helicity, self.rig, self.move, self.part)
       

class ForeWing(Formula):
    
    J = 6 #joint number
    
    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
        disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end
        
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        self.w = [0 for i in range(self.J+1)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.helicity, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)
 
        # Parent set disciple to master      
        self.setParent(self.helicity, self.move, self.rig,
                self.disciple_loc, self.disciple_rot, self.disciple)
 
        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A * 1, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A * 1, self.J, self.helicity, self.rig, self.move, self.part)
    
    # Overriding Configuration Movement
    def configMovement(self, P, A, J, helicity, a, b, y, o, w):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        y[2] = mathutils.Euler(((0.52657/0.138222)*A, (-0.803007/0.138222)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler((-A, (-1.46779/0.138222)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler((-A, (-2.42546/0.138222)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        b[2] = mathutils.Euler(((0.803012/0.138222)*A, (-0.526564/0.138222)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((0.148898/0.138222)*A, (-1.7549/0.138222)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        o[2] = mathutils.Euler(((0.813687/0.138222)*A, (-1.09012/0.138222)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((-0.191102/0.138222)*A, (-1.52068/0.138222)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])

        if helicity == 'right':
            H = 1
        else:
            H = -1
            
        w[0] = mathutils.Euler((-A , y[4].y, -B * H), 'XYZ')
        print ("w0 =", w[0])
      
        w[1] = mathutils.Euler((-A , y[4].y, -B*2 * H), 'XYZ')
        print ("w1 =", w[1])

        w[2] = mathutils.Euler((-1.105054/0.138222*A, -3.42567/0.138222*A, -0.084324/0.138222*A * H), 'XYZ')
        w[3] = mathutils.Euler((-1.105054/0.138222*A, -3.42567/0.138222*A, -0.734548/0.138222*A * H), 'XYZ')
        print ("w2 =", w[2])
        print ("w3 =", w[3])
    
        w[4] = mathutils.Euler((-1.105054/0.138222*A, -3.42567/0.138222*A, -1.312147/0.138222* A * H), 'XYZ')
        print ("w4 =", w[4])
        w[5] = mathutils.Euler((-1.105054/0.138222*A, -3.42567/0.138222*A, -5.514378/0.138222* A * H), 'XYZ')
        print ("w5 =", w[5])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 2):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-3):

                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]


        # y4 2 fulcrum vector
        y4_fulcrum = amt.edit_bones.new('y4_fulcrum')
        y4_fulcrum.head = y[4]
        y4_fulcrum.tail = w[0]
        y4_fulcrum.parent = yy[3][4]

        y4_fulcrum_tail = amt.edit_bones.new('y4_fulcrum.tail')
        y4_fulcrum_tail.head = w[0]
        y4_fulcrum_tail.tail = w[1]
        y4_fulcrum_tail.parent = y4_fulcrum


        # formula y3y4 ginbal_ring x-axis
        g_y3y4_x = amt.edit_bones.new('g_y3y4.x')
        g_y3y4_x.head = y[3]
        g_y3y4_x.tail = y[4]
        g_y3y4_x.parent = by[3][3]

        # formula y3y4 ginbal_ring z-axis
        g_y3y4_z = amt.edit_bones.new('g_y3y4.z')
        g_y3y4_z.head = y[4]
        g_y3y4_z.tail = w[0]
        g_y3y4_z.parent = g_y3y4_x

        # formula b4y4 ginbal_ring x-axis
#        g_b4y4_x = amt.edit_bones.new('g_b4y4.x')
#        g_b4y4_x.head = b[4]
#        g_b4y4_x.tail = y[4]
#        g_b4y4_x.parent = ob[3][4]

        # formula b4y4 ginbal_ring z-axis
#        g_b4y4_z = amt.edit_bones.new('g_b4y4.z')
#        g_b4y4_z.head = y[4]
#        g_b4y4_z.tail = w[0]
#        g_b4y4_z.parent = g_b4y4_x


        # fulcrum 2 y4
        fulcrum_y4 = amt.edit_bones.new('fulcrum_y4')
        fulcrum_y4.head = w[4]
        fulcrum_y4.tail = w[3]
        fulcrum_y4.parent = aa[2][1]

        # fulcrum y4 tail
        fulcrum_y4_tail = amt.edit_bones.new('fulcrum_y4.tail')
        fulcrum_y4_tail.head = w[3]
        fulcrum_y4_tail.tail = w[2]
        fulcrum_y4_tail.parent = fulcrum_y4
    

        # fulcrum gimbal 1 y-axis
        g_1_y = amt.edit_bones.new('g_1.y')
        g_1_y.head = mathutils.Euler((w[4].x, y[4].y + 0.7504, w[4].z), 'XYZ')
        g_1_y.tail = w[4]
        g_1_y.parent = aa[2][1]

        # fulcrum gimbal 2 x-axis
        g_2_x = amt.edit_bones.new('g_2.x')
        g_2_x.head = w[4]
        g_2_x.tail = w[3]
        g_2_x.parent = g_1_y
    
    
        # wings gimbal 3 z-axis
        g_3_z = amt.edit_bones.new('g_3.z')
        g_3_z.head = w[4]
        g_3_z.tail = w[5]
        g_3_z.parent = g_2_x

#        # wings gimbal 4 z-axis
#        g_4_z = amt.edit_bones.new('g_4.z')
#        g_4_z.head = w[5]
#        g_4_z.tail = w[6]
#        g_4_z.parent = g_2_x

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 2):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        # IK constraint y4 -> fulcrum
        cns = rig.pose.bones['y4_fulcrum'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'fulcrum_y4'
        cns.head_tail = 0

        # IK constraint fulcrum -> y4
        cns = rig.pose.bones['fulcrum_y4'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'y3y4'
        cns.head_tail = 1

        # IK constraint g_1.z - g_2.x - y4
        cns = rig.pose.bones['g_2.x'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'fulcrum_y4.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'fulcrum_y4'
        cns.chain_count = 2
        cns.use_stretch = False
        cns.pole_angle = math.radians(-90)

        # Copy rotation constraints
        cns = rig.pose.bones['g_3.z'].constraints.new('COPY_ROTATION')
        cns.name = 'Copy_Rotation'
        cns.target = rig
        cns.subtarget = 'g_y3y4.z'
        cns.owner_space = 'WORLD'
        cns.target_space = 'WORLD'

        # Copy rotation constraints
#        cns = rig.pose.bones['g_4.z'].constraints.new('COPY_ROTATION')
#        cns.name = 'Copy_Rotation'
#        cns.target = rig
#        cns.subtarget = 'g_b4y4.z'
#        cns.owner_space = 'WORLD'
#        cns.target_space = 'WORLD'

        # IK constraint
        cns = rig.pose.bones['g_y3y4.z'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y4_fulcrum.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'y4_fulcrum'
        cns.chain_count = 2
        cns.use_stretch = False
        cns.pole_angle = math.radians(90)

        # IK constraint
#        cns = rig.pose.bones['g_b4y4.z'].constraints.new('IK')
#        cns.name = 'Ik'
#        cns.target = rig
#        cns.subtarget = 'y4_fulcrum.tail'
#        cns.pole_target = rig
#        cns.pole_subtarget = 'y4_fulcrum'
#        cns.chain_count = 2
#        cns.use_stretch = False
#        if helicity == 'right':
#            cns.pole_angle = math.radians(90)
#        else:
#            cns.pole_angle = math.radians(-90)

        bpy.ops.object.mode_set(mode='OBJECT')


    # Parent set disciple to master      
    def setParent(self, helicity, move, rig, 
            disciple_loc, disciple_rot, disciple ):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'g_3.z' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
        
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4_fulcrum.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4_fulcrum.tail.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "fulcrum_y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "fulcrum_y4.tail.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0
#        Z = Q*17

#        obj_joint = bpy.data.objects["joint.gold.000"].copy()

        if helicity == 'left':
            obj_joint = bpy.data.objects["joint.gold.forewing.a2a1.L"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.forewing.a2a1.R"].copy()

        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 2):

            # Pattern 2 of by
            obj_joint = bpy.data.objects["joint.green.001"].copy()
            obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
            obj_joint.scale = (A, A, A)
            obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
            bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-4):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-5):

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)
                

        obj_joint = bpy.data.objects["joint.gold.y3y4.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.g_y3y4.x.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_y3y4.x.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.g_y3y4.z.forewing"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_y3y4.z.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.green.g_1.y.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_1.y.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.blue.g_2.x.wing"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_2.x.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.silver.g_3.z.wing"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_3.z.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')

    def constructLink(self, A, J, helicity, rig, move, part):

        # Move and rotate the tip bone in pose mode
        bpy.context.view_layer.objects.active = rig 

        Y = 1.1838*A

        for n in rig.pose.bones:

            if n.name != "y3o3":
#            if n.name != "o" + str(J-2) + "b" + str(J-1):
                # we can get the object from the pose bone
                obj = n.id_data
                matrix_final = obj.matrix_world @ n.matrix

                # Create armature and object
                lnk = bpy.data.armatures.new(n.name[:len(n.name)]+'.data.' + helicity)
                lnk_rig = bpy.data.objects.new(n.name[:len(n.name)]+'.link.' + helicity, lnk)
                lnk_rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')

                # rig.show_in_front = True
                lnk.show_names = True
                lnk.display_type = 'STICK'

                bpy.data.collections['link'].objects.link(lnk_rig)
                bpy.context.view_layer.objects.active = lnk_rig
                bpy.context.view_layer.update()

                # Create bones

                # mode='EDIT'
                bpy.ops.object.editmode_toggle()
    
                link = lnk.edit_bones.new(n.name[:len(n.name)])
                link.head = (0.0, 0.0, 0.0)
                link.tail = (0.0, Y, 0.0)

                link_head = lnk.edit_bones.new('head')
                link_head.head = (0.0, 0.0, 0.1)
                link_head.tail = (0.0, 0.0, 0.0)
                link_head.parent = link
                link_head.use_inherit_scale = False

                link_tail = lnk.edit_bones.new('tail')
                link_tail.head = (0.0, Y, 0.0)
                link_tail.tail = (0.0, Y, -0.1)
                link_tail.parent = link
                link_tail.use_inherit_scale = False

                bpy.ops.object.mode_set(mode='OBJECT')

                ob = bpy.data.objects[n.name[:len(n.name)]+'.mesh.' + move + '.' + part +'.' + helicity]
                ob.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
    
                # Give mesh object an armature modifier, using vertex groups but
                # not envelopes
                mod = ob.modifiers.new('MyRigModif', 'ARMATURE')
                mod.object = lnk_rig
                mod.use_bone_envelopes = False
                mod.use_vertex_groups = True

                # Bone constraints. Armature must be in pose mode.
                bpy.ops.object.mode_set(mode='POSE')
 
                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_LOCATION')
                cns.name = 'Copy_Location'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_ROTATION')
                cns.name = 'Copy_Rotation'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # StretchTo constraint Mid -> Tip with influence 0.5
                cns1 = pBase.constraints.new('STRETCH_TO')
                cns1.name = 'Stretch'
                cns1.target = rig
                cns1.subtarget = n.name[:len(n.name)]
                cns1.head_tail = 1
                cns1.rest_length = Y
                cns1.influence = 1
                cns1.keep_axis = 'PLANE_Z'
                cns1.volume = 'NO_VOLUME'

                bpy.ops.object.mode_set(mode='OBJECT')


class LeftArm(Formula):

    J = 8 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Joints ω(n) -> w[n]
        self.w = [0 for i in range(self.J)] # Joint ω

        # gimbal
        self.gimbal_b = [0 for i in range(self.J)] # Joint β
        self.gimbal_y = [0 for i in range(self.J)] # Joint γ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J,
            self.a, self.b, self.y, self.o,
            self.w,
            self.gimbal_b, self.gimbal_y)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.part,
            self.amt, self.rig, 
            self.a, self.b, self.y, self.o,
            self.w,
            self.gimbal_b, self.gimbal_y)

        # Construction Rotation
#        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.8779325, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.8779325, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w, gimbal_b, gimbal_y):

        w[1] = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        print ("w1 =", w[1])

        o[1] = mathutils.Euler(((-0.2/0.4)*A, 0.0, 0.0), 'XYZ')
        print ("o1 =", o[1])

        b[2] = mathutils.Euler(((1.23875/0.4)*A, 0.0, 0.0), 'XYZ')
        print ("b2 =", b[2])

        y[3] = mathutils.Euler(((1.23875/0.4)*A, (-6.58841/0.4)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])
        
        y[4] = mathutils.Euler(((1.23875/0.4)*A, (-11.8418/0.4)*A, (1.85078/0.4)*A), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((1.23875/0.4)*A, (-12.4749/0.4)*A, (1.85078/0.4)*A), 'XYZ')
        print ("y5 =", y[5])

        y[6] = mathutils.Euler(((11.103521/0.4)*A, (17.42206/0.4)*A, (-12.820685/0.4)*A), 'XYZ')
        print ("y6 =", y[6])

        y[7] = mathutils.Euler(((11.103521/0.4)*A, (17.42206/0.4)*A, (-14.059485/0.4)*A), 'XYZ')
        print ("y7 =", y[7])

        gimbal_b[2] = mathutils.Euler(((1.23875/0.4)*A, 0.0, 0.0), 'XYZ')
        print ("b2.gimbal =", gimbal_b[2])

        gimbal_y[3] = mathutils.Euler(((1.23875/0.4)*A, (-6.58841/0.4)*A, 0.0), 'XYZ')
        print ("y3.gimbal =", gimbal_y[3])
        

    def constructMovement(self, J, helicity, part,
        amt, rig, a, b, y, o, w, gimbal_b, gimbal_y):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        ow = [[0 for i in range(2)] for j in range(self.J)] # δ(j) - ω(j)

        gimbal_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        gimbal_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()
 
        ow[1][1] = amt.edit_bones.new('o1w1')
        ow[1][1].head = o[1]
        ow[1][1].tail = w[1]
#        ow[1][1].parent = yo[1][1]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = w[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ow[1][1]

        by[2][3] = amt.edit_bones.new('b2y3')
        by[2][3].head = b[2]
        by[2][3].tail = y[3]
        by[2][3].parent = ob[1][2]

        # gimbal
        gimbal_ob[1][2] = amt.edit_bones.new('o1b2.gimbal')
        gimbal_ob[1][2].head = w[1]
        gimbal_ob[1][2].tail = gimbal_b[2]
        gimbal_ob[1][2].parent = ow[1][1]

        gimbal_by[2][3] = amt.edit_bones.new('b2y3.gimbal')
        gimbal_by[2][3].head = gimbal_b[2]
        gimbal_by[2][3].tail = gimbal_y[3]
        gimbal_by[2][3].parent = gimbal_ob[1][2]
        # end

        yy[3][4] = amt.edit_bones.new('y3y4')
        yy[3][4].head = y[3]
        yy[3][4].tail = y[4]
        yy[3][4].parent = by[2][3]

        yy[4][5] = amt.edit_bones.new('y4y5')
        yy[4][5].head = y[4]
        yy[4][5].tail = y[5]
        yy[4][5].parent = yy[3][4]

        yy[6][7] = amt.edit_bones.new('y6y7')
        yy[6][7].head = y[6]
        yy[6][7].tail = y[7]
        yy[6][7].parent = ob[1][2]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'left ':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
              
        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="DESELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        amt.edit_bones["b2y3"].select = True
        amt.edit_bones["y3y4"].select = True
        amt.edit_bones["y4y5"].select = True

        bpy.ops.armature.calculate_roll(type='GLOBAL_POS_X')
 
        # IK constraint
        cns = rig.pose.bones['b2y3.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y3y4'
        cns.pole_target = rig
        cns.pole_subtarget = 'b2y3'
        cns.pole_angle = math.radians(0)

#        if part == 'leg-left':
#            cns.pole_angle = math.radians(0)
#        else:
#            cns.pole_angle = math.radians(180)
            
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        n = 1

        obj_joint = bpy.data.objects["joint.gold.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o1w1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o1b2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b2y3.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.g1.y.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o1b2.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.g1.z.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b2y3.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, Q +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.gold.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4y5.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y6y7.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class RightArm(LeftArm):

    J = 8 #joint number

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w, gimbal_b, gimbal_y):

        w[1] = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        print ("w1 =", w[1])

        o[1] = mathutils.Euler(((-0.2/0.4)*A, 0.0, 0.0), 'XYZ')
        print ("o1 =", o[1])

        b[2] = mathutils.Euler(((1.23875/0.4)*A, 0.0, 0.0), 'XYZ')
        print ("b2 =", b[2])

        y[3] = mathutils.Euler(((1.23875/0.4)*A, (-6.58841/0.4)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])
        
        y[4] = mathutils.Euler(((1.23875/0.4)*A, (-11.8418/0.4)*A, (1.85078/0.4)*A), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((1.23875/0.4)*A, (-12.4749/0.4)*A, (1.85078/0.4)*A), 'XYZ')
        print ("y5 =", y[5])

        y[6] = mathutils.Euler(((28.6854/0.4)*A, (-15.175/0.4)*A, (10.2097/0.4)*A), 'XYZ')
        print ("y6 =", y[6])

        y[7] = mathutils.Euler(((28.6854/0.4)*A, (-15.175/0.4)*A, (8.97093/0.4)*A), 'XYZ')
        print ("y7 =", y[7])

        gimbal_b[2] = mathutils.Euler(((1.23875/0.4)*A, 0.0, 0.0), 'XYZ')
        print ("b2.gimbal =", gimbal_b[2])

        gimbal_y[3] = mathutils.Euler(((1.23875/0.4)*A, (-6.58841/0.4)*A, 0.0), 'XYZ')
        print ("y3.gimbal =", gimbal_y[3])
        

class Head(Formula):

    J = 4 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        y[2] = mathutils.Euler((-A, (-1/0.747868)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-2.44947/0.747868)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])
        
        b[2] = mathutils.Euler(((-2.44425/0.747868)*A, -A, (0.711801/0.747868)*A), 'XYZ')
        print ("b2 =", b[2])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
#        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = yo[1][1]
   
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        # Pattern 1 of ob
#        obj_joint = bpy.data.objects["joint.blue.001"].copy()
#        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint = bpy.data.objects["joint.gold.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Neck(Wrist):
    
    J = 3 #joint number

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, -(0.173028/0.351)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-0.77453/0.351)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1a2' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        

class RightShoulder(Formula):

    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
            disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/0.431828)*A, (A/0.431828)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((0.222378/0.431828)*A, (-0.516001/0.431828)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((0.344001/0.431828)*A, (-0.344001/0.431828)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])
        
        b[5] = mathutils.Euler(((-0.786222/0.431828)*A, (2.50622/0.431828)*A, 0.0), 'XYZ')
        print ("b5 =", b[5])

        y[2] = mathutils.Euler(((A/0.431828)*A, (-A/0.431828)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((0.222378/0.431828)*A, (-0.637623/0.431828)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((A/0.431828)*A, (-A/0.431828)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((A/0.431828)*A, (2.50622/0.431828)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

        y[6] = mathutils.Euler(((A/0.431828)*A, (2.79985/0.431828)*A, 0.0), 'XYZ')
        print ("y6 =", y[6])

        o[2] = mathutils.Euler(((0.516001/0.431828)*A, (-0.516001/0.431828)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((0.344001/0.431828)*A, (-0.637623/0.431828)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        o[4] = mathutils.Euler(((-0.786222/0.431828)*A, (-A/0.431828)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])
        
        o[5] = mathutils.Euler(((0.308378/0.431828)*A, (2.50622/0.431828)*A, 0.0), 'XYZ')
        print ("o5 =", o[5])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b5y5' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        

class LeftShoulder(Formula):

    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
            disciple_loc, disciple_rot, disciple, disciple2_loc, disciple2_rot, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple
        
        # disciple position
        self.disciple2_loc = disciple2_loc
        self.disciple2_rot = disciple2_rot

        # disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot,
            self.disciple, self.disciple2_loc, self.disciple2_rot, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/0.431828)*A, (A/0.431828)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((0.222378/0.431828)*A, (-0.516001/0.431828)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((0.344001/0.431828)*A, (-0.344001/0.431828)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])
        
        b[5] = mathutils.Euler(((-0.786223/0.431828)*A, (-3.36622/0.431828)*A, 0.0), 'XYZ')
        print ("b5 =", b[5])

        y[2] = mathutils.Euler(((A/0.431828)*A, (-A/0.431828)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((0.222378/0.431828)*A, (-0.637623/0.431828)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler(((A/0.431828)*A, (-A/0.431828)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((A/0.431828)*A, (-3.36622/0.431828)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

        y[6] = mathutils.Euler(((A/0.431828)*A, (-3.65985/0.431828)*A, 0.0), 'XYZ')
        print ("y6 =", y[6])

        o[2] = mathutils.Euler(((0.516001/0.431828)*A, (-0.516001/0.431828)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((0.344001/0.431828)*A, (-0.637623/0.431828)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        o[4] = mathutils.Euler(((-0.786223/0.431828)*A, (-A/0.431828)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])
        
        o[5] = mathutils.Euler(((0.308378/0.431828)*A, (-3.36622/0.431828)*A, 0.0), 'XYZ')
        print ("o5 =", o[5])

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple, 
            disciple2_loc, disciple2_rot, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y2y3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        #disciple
        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b5y5' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        #disciple2
        disciple2.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple2 position
        disciple2.rig.location.x += disciple2_loc[0]
        disciple2.rig.location.y += disciple2_loc[1]
        disciple2.rig.location.z += disciple2_loc[2]

        disciple2.rig.rotation_euler = disciple2_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Costa(Formula):

    J = 4 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
        disciple_loc, disciple_rot, disciple, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, 
            self.disciple_loc, self.disciple_rot, self.disciple, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A*0.4, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A*0.4, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, (-0.581324/0.431828)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-3.59276/0.431828)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])
        
        b[2] = mathutils.Euler(((-3.59276/0.431828)*A, (-0.581324/0.431828)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        o[2] = mathutils.Euler((-A, (-0.664808/0.431828)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
#        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = yo[1][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        by[2][2] = amt.edit_bones.new('b'+ str(2) + 'y'+ str(2))
        by[2][2].head = b[2]
        by[2][2].tail = y[2]
        by[2][2].parent = ob[1][2]

        yo[2][2] = amt.edit_bones.new('y'+ str(2) + 'o'+ str(2))
        yo[2][2].head = y[2]
        yo[2][2].tail = o[2]
        yo[2][2].parent = yy[1][2]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['b2y2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y2o2'
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, 
        disciple_loc, disciple_rot, disciple, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1o1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)
        disciple2.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
                
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

        # disciple2 position
        disciple2.rig.location.x += disciple_loc[0]
        disciple2.rig.location.y += disciple_loc[1]
        disciple2.rig.location.z += disciple_loc[2]

        disciple2.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 1 of ob
        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yo
        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 2
        
        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.b2y2"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Spine(Formula):

    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
            disciple_loc, disciple_rot, disciple,
            disciple2_loc, disciple2_rot, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple position
        self.disciple2_loc = disciple2_loc
        self.disciple2_rot = disciple2_rot

        # disciple
        self.disciple = disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, 
            self.disciple_loc, self.disciple_rot, self.disciple, 
            self.disciple2_loc, self.disciple2_rot, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(1.25*self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(1.25*self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((3.37305/0.578724)*A, (-2.2156/0.578724)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((3.37305/0.578724)*A, (-6.16738/0.578724)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        b[4] = mathutils.Euler(((1.05816/0.578724)*A, (-4.5305/0.578724)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])

        y[2] = mathutils.Euler(((2.2156/0.578724)*A, (-3.37305/0.578724)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((5.00993/0.578724)*A, (-6.16738/0.578724)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = b[2]
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((5.00993/0.578724)*A, (-4.5305/0.578724)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
                
        y[4] = y[2]
        print ("y4 =", y[4])
        
        o[4] = b[4]
        print ("o4 =", o[4])

        b[5] = mathutils.Euler(((-1.73617/0.578724)*A, (-1.73617/0.578724)*A, 0.0), 'XYZ')
        print ("b5 =", b[5])

        y[5] = y[1]
        print ("y5 =", y[5])

        o[5] = b[5]
        
        y[6] = mathutils.Euler(((-3.37305/0.578724)*A, (2.2156/0.578724)*A, 0.0), 'XYZ')
        print ("y6 =", y[6])

    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, 
        disciple_loc, disciple_rot, disciple,
        disciple2_loc, disciple2_rot, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y5y6' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
        
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3y4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple2.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
        
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

        # disciple2 position
        disciple2.rig.location.x += disciple2_loc[0]
        disciple2.rig.location.y += disciple2_loc[1]
        disciple2.rig.location.z += disciple2_loc[2]

        disciple2.rig.rotation_euler = disciple2_rot


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.spine.a2a1"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):
            
            if n >= (3):
                N=-Q*5
            else:
                N=-Q*0

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, N-Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                if n == (2):
                    obj_joint = bpy.data.objects["joint.gold.spine.y2y3"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()

                obj_joint.location = (0.0, 0.0, N+Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 1 of ob
                if n == (2):
                    obj_joint = bpy.data.objects["joint.blue.spine.o2b3"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.blue.001"].copy()
                    
                obj_joint.location = (0.0, 0.0, N-Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                if n == (2):
                    obj_joint = bpy.data.objects["joint.copper.spine.y3o3"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.copper.001"].copy()

                obj_joint.location = (0.0, 0.0, N-Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.gold.spine.y5y6"].copy()
        obj_joint.location = (0.0, 0.0, N+Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y5y6.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class LeftIlium(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master       
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.2677480422, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.2677480422, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/1.03339)*A, (A/1.03339)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((-A/1.03339)*A, (-A*3/1.03339)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        y[2] = mathutils.Euler(((A/1.03339)*A, (-A/1.03339)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((A/1.03339)*A, (-A*3/1.03339)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((-A/1.03339)*A, (-A/1.03339)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((A/1.03339)*A, (-A*5/1.03339)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
#        y[4] = mathutils.Euler(((A*3/1.03339)*A, (-A*3/1.03339)*A, 0.0), 'XYZ')
        y[4] = mathutils.Euler(((2.62491/1.03339)*A, (-4.504337/1.03339)*A, (0.684476/1.03339)*A), 'XYZ')
        print ("y4 =", y[4])
        
    # Parent set disciple to master        
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b3y3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*0+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.002"].copy()
        obj_joint.location = (0.0, 0.0, +Q*4+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*6+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*1+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                if n == 1:
                    
                    obj_joint = bpy.data.objects["joint.green.002"].copy()
                    obj_joint.location = (0.0, 0.0, +Q*2 + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                elif n == 3:
                    
                    if part == 'ilium-left':
                        obj_joint = bpy.data.objects["joint.green.ilium.b3y3.L"].copy()

                    else:
                        obj_joint = bpy.data.objects["joint.green.ilium.b3y3.R"].copy()
                    
                    obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                else:
                    # Pattern 2 of by
                    obj_joint = bpy.data.objects["joint.green.001"].copy()
                    obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                if n == 1:
                    # Pattern 1 of ob
                    obj_joint = bpy.data.objects["joint.blue.002"].copy()
                    obj_joint.location = (0.0, 0.0, +Q*1 + Q*(n % 2)*6 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                else:
                    # Pattern 1 of ob
                    obj_joint = bpy.data.objects["joint.blue.001"].copy()
                    obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                    obj_joint.scale = (A, A, A)
                    obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                    bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.spine.y3y4"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (3 % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class RightIlium(LeftIlium):

    J = 5 #joint number

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D
        
        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((A*3/1.03339)*A, (A/1.03339)*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((-A/1.03339)*A, (A/1.03339)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        y[2] = mathutils.Euler(((A/1.03339)*A, (-A/1.03339)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((A/1.03339)*A, (A/1.03339)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((-A/1.03339)*A, (-A/1.03339)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((A/1.03339)*A, (A*3/1.03339)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler(((A*3/1.03339)*A, (A/1.03339)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])


class HindWing(ForeWing):
    
    J = 6 #joint number
    
    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
        disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end
        
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        self.w = [0 for i in range(self.J+1)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.helicity, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)
 
        # Parent set disciple to master      
        self.setParent(self.helicity, self.move, self.rig,
                self.disciple_loc, self.disciple_rot, self.disciple)
 
        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A * 1, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A * 1, self.J, self.helicity, self.rig, self.move, self.part)


    # Overriding Configuration Movement
    def configMovement(self, P, A, J, helicity, a, b, y, o, w):
        
        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        y[2] = mathutils.Euler((1.404781*A, -3.404781*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler((-1*A, -5.809552*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        y[4] = mathutils.Euler((-1*A, -9.273811*A, 0.0), 'XYZ')
        print ("y4 =", y[4])

        b[2] = mathutils.Euler((3.404781*A, -1.404781*A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler((0.113741/0.276443*A, -1.60524/0.276443*A, 0.0), 'XYZ')
        print ("b3 =", b[3])

        o[2] = mathutils.Euler((0.777763/0.276443*A, -0.941228/0.276443*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler((-1.191309*A, -6.000875*A, 0.0), 'XYZ')
        print ("o3 =", o[3])

        if helicity == 'right':
            H = 1
        else:
            H = -1
            
        w[0] = mathutils.Euler((-A , y[4].y, -B * H), 'XYZ')
        print ("w0 =", w[0])
      
        w[1] = mathutils.Euler((-A , y[4].y, -B*2 * H), 'XYZ')
        print ("w1 =", w[1])

        w[2] = mathutils.Euler((-0.933934/0.276443*A, -2.41649/0.276443*A, -2.53093/0.276443*A * H), 'XYZ')
        w[3] = mathutils.Euler((-0.933934/0.276443*A, -2.41649/0.276443*A, -3.18115/0.276443*A * H), 'XYZ')
        print ("w2 =", w[2])
        print ("w3 =", w[3])
    
        w[4] = mathutils.Euler((-0.933934/0.276443*A, -2.41649/0.276443*A, -3.75874/0.276443* A * H), 'XYZ')
        print ("w4 =", w[4])
        w[5] = mathutils.Euler((-0.933934/0.276443*A, -2.41649/0.276443*A, -6.05221/0.276443* A * H), 'XYZ')
        print ("w5 =", w[5])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 2):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-3):

                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]


        # y4 2 fulcrum vector
        y4_fulcrum = amt.edit_bones.new('y4_fulcrum')
        y4_fulcrum.head = y[4]
        y4_fulcrum.tail = w[0]
        y4_fulcrum.parent = yy[3][4]

        y4_fulcrum_tail = amt.edit_bones.new('y4_fulcrum.tail')
        y4_fulcrum_tail.head = w[0]
        y4_fulcrum_tail.tail = w[1]
        y4_fulcrum_tail.parent = y4_fulcrum


        # formula y3y4 ginbal_ring x-axis
        g_y3y4_x = amt.edit_bones.new('g_y3y4.x')
        g_y3y4_x.head = y[3]
        g_y3y4_x.tail = y[4]
        g_y3y4_x.parent = by[3][3]

        # formula y3y4 ginbal_ring z-axis
        g_y3y4_z = amt.edit_bones.new('g_y3y4.z')
        g_y3y4_z.head = y[4]
        g_y3y4_z.tail = w[0]
        g_y3y4_z.parent = g_y3y4_x

        # formula b4y4 ginbal_ring x-axis
#        g_b4y4_x = amt.edit_bones.new('g_b4y4.x')
#        g_b4y4_x.head = b[4]
#        g_b4y4_x.tail = y[4]
#        g_b4y4_x.parent = ob[3][4]

        # formula b4y4 ginbal_ring z-axis
#        g_b4y4_z = amt.edit_bones.new('g_b4y4.z')
#        g_b4y4_z.head = y[4]
#        g_b4y4_z.tail = w[0]
#        g_b4y4_z.parent = g_b4y4_x


        # fulcrum 2 y4
        fulcrum_y4 = amt.edit_bones.new('fulcrum_y4')
        fulcrum_y4.head = w[4]
        fulcrum_y4.tail = w[3]
        fulcrum_y4.parent = aa[2][1]

        # fulcrum y4 tail
        fulcrum_y4_tail = amt.edit_bones.new('fulcrum_y4.tail')
        fulcrum_y4_tail.head = w[3]
        fulcrum_y4_tail.tail = w[2]
        fulcrum_y4_tail.parent = fulcrum_y4
    

        # fulcrum gimbal 1 y-axis
        g_1_y = amt.edit_bones.new('g_1.y')
        g_1_y.head = mathutils.Euler((w[4].x, y[4].y + 0.7504, w[4].z), 'XYZ')
        g_1_y.tail = w[4]
        g_1_y.parent = aa[2][1]

        # fulcrum gimbal 2 x-axis
        g_2_x = amt.edit_bones.new('g_2.x')
        g_2_x.head = w[4]
        g_2_x.tail = w[3]
        g_2_x.parent = g_1_y
    
    
        # wings gimbal 3 z-axis
        g_3_z = amt.edit_bones.new('g_3.z')
        g_3_z.head = w[4]
        g_3_z.tail = w[5]
        g_3_z.parent = g_2_x

#        # wings gimbal 4 z-axis
#        g_4_z = amt.edit_bones.new('g_4.z')
#        g_4_z.head = w[5]
#        g_4_z.tail = w[6]
#        g_4_z.parent = g_2_x

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 2):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        # IK constraint y4 -> fulcrum
        cns = rig.pose.bones['y4_fulcrum'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'fulcrum_y4'
        cns.head_tail = 0

        # IK constraint fulcrum -> y4
        cns = rig.pose.bones['fulcrum_y4'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'y3y4'
        cns.head_tail = 1

        # IK constraint g_1.z - g_2.x - y4
        cns = rig.pose.bones['g_2.x'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'fulcrum_y4.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'fulcrum_y4'
        cns.chain_count = 2
        cns.use_stretch = False
        cns.pole_angle = math.radians(-90)

        # Copy rotation constraints
        cns = rig.pose.bones['g_3.z'].constraints.new('COPY_ROTATION')
        cns.name = 'Copy_Rotation'
        cns.target = rig
        cns.subtarget = 'g_y3y4.z'
        cns.owner_space = 'WORLD'
        cns.target_space = 'WORLD'

        # Copy rotation constraints
#        cns = rig.pose.bones['g_4.z'].constraints.new('COPY_ROTATION')
#        cns.name = 'Copy_Rotation'
#        cns.target = rig
#        cns.subtarget = 'g_b4y4.z'
#        cns.owner_space = 'WORLD'
#        cns.target_space = 'WORLD'

        # IK constraint
        cns = rig.pose.bones['g_y3y4.z'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y4_fulcrum.tail'
        cns.pole_target = rig
        cns.pole_subtarget = 'y4_fulcrum'
        cns.chain_count = 2
        cns.use_stretch = False
        cns.pole_angle = math.radians(90)

        # IK constraint
#        cns = rig.pose.bones['g_b4y4.z'].constraints.new('IK')
#        cns.name = 'Ik'
#        cns.target = rig
#        cns.subtarget = 'y4_fulcrum.tail'
#        cns.pole_target = rig
#        cns.pole_subtarget = 'y4_fulcrum'
#        cns.chain_count = 2
#        cns.use_stretch = False
#        if helicity == 'right':
#            cns.pole_angle = math.radians(90)
#        else:
#            cns.pole_angle = math.radians(-90)

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
        
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4_fulcrum.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4_fulcrum.tail.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "fulcrum_y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "fulcrum_y4.tail.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0
#        Z = Q*17

#        obj_joint = bpy.data.objects["joint.gold.000"].copy()

        if helicity == 'right':
            obj_joint = bpy.data.objects["joint.gold.hindwing.a2a1.L"].copy()
        else:
            obj_joint = bpy.data.objects["joint.gold.hindwing.a2a1.R"].copy()

        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 2):

            # Pattern 2 of by
            obj_joint = bpy.data.objects["joint.green.001"].copy()
            obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
            obj_joint.scale = (A, A, A)
            obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
            bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-4):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

            if n <= (J-5):

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)
                

        obj_joint = bpy.data.objects["joint.gold.y3y4.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.g_y3y4.x.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_y3y4.x.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.g_y3y4.z.hindwing"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_y3y4.z.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.green.g_1.y.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_1.y.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.blue.g_2.x.hindwing.wing"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_2.x.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.silver.g_3.z.hindwing.wing"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "g_3.z.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Legs(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Joints ω(n) -> w[n]
        self.w = [0 for i in range(self.J)] # Joint ω

        # gimbal
        self.gimbal_b = [0 for i in range(self.J)] # Joint β
        self.gimbal_y = [0 for i in range(self.J)] # Joint γ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J,
            self.a, self.b, self.y, self.o,
            self.w,
            self.gimbal_b, self.gimbal_y)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.part,
            self.amt, self.rig, 
            self.a, self.b, self.y, self.o,
            self.w,
            self.gimbal_b, self.gimbal_y)

        # Construction Rotation
#        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w, gimbal_b, gimbal_y):

        w[1] = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        print ("w1 =", w[1])

        o[1] = mathutils.Euler(((-0.2/0.351173)*A, 0.0, 0.0), 'XYZ')
        print ("o1 =", o[1])

        b[2] = mathutils.Euler(((1.21162/0.351173)*A, 0.0, 0.0), 'XYZ')
        print ("b2 =", b[2])

        y[3] = mathutils.Euler(((1.21162/0.351173)*A, (-10.7995/0.351173)*A, (3.28478/0.351173)*A), 'XYZ')
        print ("y3 =", y[3])
        
        y[4] = mathutils.Euler(((1.21162/0.351173)*A, (-19.0264/0.351173)*A, (0.226179/0.351173)*A), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler(((1.21162/0.351173)*A, (-20.6094/0.351173)*A, (2.464/0.351173)*A), 'XYZ')
        print ("y5 =", y[5])

        gimbal_b[2] = mathutils.Euler(((1.21162/0.351173)*A, 0.0, 0.0), 'XYZ')
        print ("b2.gimbal =", gimbal_b[2])

        gimbal_y[3] = mathutils.Euler(((1.21162/0.351173)*A, (-11.288/0.351173)*A, 0.0), 'XYZ')
        print ("y3.gimbal =", gimbal_y[3])
        

    def constructMovement(self, J, helicity, part,
        amt, rig, a, b, y, o, w, gimbal_b, gimbal_y):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        ow = [[0 for i in range(2)] for j in range(self.J)] # δ(j) - ω(j)

        gimbal_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        gimbal_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()
 
        ow[1][1] = amt.edit_bones.new('o1w1')
        ow[1][1].head = o[1]
        ow[1][1].tail = w[1]
#        ow[1][1].parent = yo[1][1]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = w[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ow[1][1]

        by[2][3] = amt.edit_bones.new('b2y3')
        by[2][3].head = b[2]
        by[2][3].tail = y[3]
        by[2][3].parent = ob[1][2]

        # gimbal
        gimbal_ob[1][2] = amt.edit_bones.new('o1b2.gimbal')
        gimbal_ob[1][2].head = w[1]
        gimbal_ob[1][2].tail = gimbal_b[2]
        gimbal_ob[1][2].parent = ow[1][1]

        gimbal_by[2][3] = amt.edit_bones.new('b2y3.gimbal')
        gimbal_by[2][3].head = gimbal_b[2]
        gimbal_by[2][3].tail = gimbal_y[3]
        gimbal_by[2][3].parent = gimbal_ob[1][2]
        # end

        yy[3][4] = amt.edit_bones.new('y3y4')
        yy[3][4].head = y[3]
        yy[3][4].tail = y[4]
        yy[3][4].parent = by[2][3]

        yy[4][5] = amt.edit_bones.new('y4y5')
        yy[4][5].head = y[4]
        yy[4][5].tail = y[5]
        yy[4][5].parent = yy[3][4]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
              
        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="DESELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        amt.edit_bones["b2y3"].select = True
        amt.edit_bones["y3y4"].select = True
        amt.edit_bones["y4y5"].select = True

        bpy.ops.armature.calculate_roll(type='GLOBAL_POS_X')
 
        # IK constraint
        cns = rig.pose.bones['b2y3.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y3y4'
        cns.pole_target = rig
        cns.pole_subtarget = 'b2y3'
        cns.pole_angle = math.radians(0)

#        if part == 'leg-left':
#            cns.pole_angle = math.radians(0)
#        else:
#            cns.pole_angle = math.radians(180)
            
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        n = 1

        obj_joint = bpy.data.objects["joint.gold.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o1w1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o1b2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b2y3.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.g1.y.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o1b2.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.g1.z.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b2y3.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, Q +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.gold.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4y5.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        
        
class Sacrum(Formula):

    J = 4 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
            disciple_loc, disciple_rot, disciple, disciple2):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple
        self.disciple2 = disciple2

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master        
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple, self.disciple2)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = a[2]
        print ("b2 =", b[2])
        
        y[2] = mathutils.Euler((-A, -A*3, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler((-A, -A*3.5, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler((-A*0.5, -A*3, 0.0), 'XYZ')
        print ("o2 =", o[2])
        

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple, disciple2):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1y2' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)
        disciple2.rig.select_set(state=True)
        
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        
        disciple2.rig.location.x += disciple_loc[0]
        disciple2.rig.location.y += disciple_loc[1]
        disciple2.rig.location.z += disciple_loc[2]

        disciple2.rig.rotation_euler = disciple_rot
        
    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
#                if n == 3:
#                    obj_joint = bpy.data.objects["joint.gold.y3y4.shoulder.thoracic"].copy()
#                else:
#                    obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()                    
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()                    

                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')

        
class Thoracic(Formula):

    J = 6 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master        
        self.setParent(self.helicity, self.move, self.rig, self.disciple_loc, self.disciple_rot, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.6, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0.0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])

        b[2] = mathutils.Euler(((1.6125/0.539785)*A, A, 0.0), 'XYZ')
        print ("b2 =", b[2])

        b[3] = mathutils.Euler(((0.277888/0.539785)*A, (-0.645/0.539785)*A, 0.0), 'XYZ')
        print ("b3 =", b[3])
        
        b[4] = mathutils.Euler(((-1.24461/0.539785)*A, (2.87553/0.539785)*A, 0.0), 'XYZ')
        print ("b4 =", b[4])
        
        y[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        y[3] = mathutils.Euler(((0.277973/0.539785)*A, (-0.797027/0.539785)*A, 0.0), 'XYZ')
        print ("y3 =", y[3])

        o[2] = mathutils.Euler(((0.645/0.539785)*A, (-0.645/0.539785)*A, 0.0), 'XYZ')
        print ("o2 =", o[2])
        
        o[3] = mathutils.Euler(((-1.24231/0.539785)*A, (-0.797027/0.539785)*A, 0.0), 'XYZ')
        print ("o3 =", o[3])
        
        o[4] = mathutils.Euler(((0.125947/0.539785)*A, (2.87554/0.539785)*A, 0.0), 'XYZ')
        print ("o4 =", o[4])
        
        y[4] = mathutils.Euler(((0.277954/0.539785)*A, (2.87554/0.539785)*A, 0.0), 'XYZ')
        print ("y4 =", y[4])
        
        y[5] = mathutils.Euler(((0.277952/0.539785)*A, (3.24257/0.539785)*A, 0.0), 'XYZ')
        print ("y5 =", y[5])

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3y4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot
        
    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yy
                if n == 3:
                    obj_joint = bpy.data.objects["joint.gold.y3y4.shoulder.thoracic"].copy()
                else:
                    obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()                    

                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.data.collections['link'].objects.link(obj_joint)


        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Foot(Formula):

    J = 3 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
        disciple_loc, disciple_rot, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # disciple position
        self.disciple_loc = disciple_loc
        self.disciple_rot = disciple_rot

        # disciple
        self.disciple = disciple

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master
        self.setParent(self.helicity, self.move, self.rig,
            self.disciple_loc, self.disciple_rot, self.disciple)
        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, -(0.173028/0.431828)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler(((-0.77453/0.431828)*A, -A, 0.0), 'XYZ')
        print ("o1 =", o[1])
        
        b[2] = mathutils.Euler((P, -A*3, 0.0), 'XYZ')
        print ("b2 =", b[2])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        ba = [[0 for i in range(4)] for j in range(4)] # Link β(i) - α(j)
    
        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_in_front = True
        amt.show_names = True
        amt.display_type = 'STICK'
#        amt.display_type = 'BBONE'

        # Link object to scene

        bpy.data.collections['movement'].objects.link(rig)
        bpy.context.view_layer.objects.active = rig
        bpy.context.view_layer.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        yo[1][1] = amt.edit_bones.new('y1o1')
        yo[1][1].head = y[1]
        yo[1][1].tail = o[1]
        yo[1][1].parent = ya[1][2]
   
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        ba[2][2] = amt.edit_bones.new('b2a2')
        ba[2][2].head = b[2]
        ba[2][2].tail = a[2]
        ba[2][2].parent = aa[2][1]

        # all bones select

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        bpy.ops.pose.select_all(action="SELECT")

        # Edit
        bpy.ops.object.editmode_toggle()

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple_loc, disciple_rot, disciple):

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y1o1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        disciple.rig.select_set(state=True)

        rig.select_set(state=True)
        bpy.context.view_layer.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # disciple position
        disciple.rig.location.x += disciple_loc[0]
        disciple.rig.location.y += disciple_loc[1]
        disciple.rig.location.z += disciple_loc[2]

        disciple.rig.rotation_euler = disciple_rot

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.foot.a2a1"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1.thoracic.B"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b2a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        

class Heel(Foot):

    J = 3 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, disciple):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        # disciple
        self.disciple = disciple

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Parent set disciple to master
        self.setParent(self.helicity, self.move, self.rig, self.disciple)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.4271380752/(self.A/0.702349), self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.4271380752/(self.A/0.702349), self.J, self.helicity, self.rig, self.move, self.part)

    # Parent set disciple to master
    def setParent(self, helicity, move, rig, disciple):

        cns = disciple.rig.pose.bones['y3y4'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y1a2'
        cns.pole_target = rig
        cns.pole_subtarget = 'b2a2'
        cns.pole_angle = math.radians(0)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        cns = disciple.rig.pose.bones['y4y5'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = rig
        cns.subtarget = 'a2a1'
        
    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.heel.a2a1"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b2a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)
        
        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class Jump(Wrist):

    J = 3 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(self.J)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.2, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.2, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o):

        a[1] = mathutils.Euler((P, A, 0.0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0.0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0.0), 'XYZ')
        print ("b1 =", b[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0.0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((-A, -(0.173028/1.58683)*A, 0.0), 'XYZ')
        print ("y2 =", y[2])

        o[1] = mathutils.Euler((-A, (-1.76222/1.58683)*A, 0.0), 'XYZ')
        print ("o1 =", o[1])

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
#        Z = Q*50
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.jump.drummajor"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y1o1"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1o1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        n = 1

        # Pattern 2 of by
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        # Pattern 2 of yy
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.data.collections['link'].objects.link(obj_joint)

        for ob in data.collections['link'].objects:
            if "mesh" in ob.name:
                ob.select_set(state = True, view_layer = None)

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, animation=True)
        bpy.context.scene.cursor.location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')
        

def formula():

# pivot factor
    P = 0

# scale factor
    A = 1
    
# joint number
    J = 9
    
# name
    move = 'formula'

# element
    part = 'universe'

# left or right
    helicity = 'left'

    start = 0
    end = start+360

    formula = Formula(P, A, J, move, part, helicity, start, end)


def hands():

# name
    move = 'swinging-drummajor'

    # scale factor
    A = 0.107

    # pivot factor
    P = -0.048266

# config nonlocal
    global middle_left
    global middle_right

# finger element
    part = 'middle-left'

# phalanx length
    y2 = mathutils.Euler((1.427, -1.08668, 0.0), 'XYZ')
    y3 = mathutils.Euler((2.15534, -1.56395, 0.0), 'XYZ')
    y4 = mathutils.Euler((2.67012, -1.90121, 0.0), 'XYZ')
    y5 = mathutils.Euler((2.90459, -2.05473, 0.0), 'XYZ')

# left finger element
    helicity = 'left'

    start = 136
    end = start+0

    middle_left = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)
    
    middle_left.rig.location = (0.0, 0.0, 0.0)
    middle_left.rig.rotation_euler = mathutils.Euler((math.radians(0), math.radians(0), math.radians(0)), 'XYZ')

# finger element
    part = 'middle-right'

# right finger element
    helicity = 'right'

    start = 112
    end = start+0

    middle_right = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)    

    middle_right.rig.location = (0.0, 0.0, 0.0)
    middle_right.rig.rotation_euler = mathutils.Euler((math.radians(180-0), math.radians(0), math.radians(0)), 'XYZ')


# finger element
    part = 'ring-left'

    y2 = mathutils.Euler((1.36978, -1.04933, 0.0), 'XYZ')
    y3 = mathutils.Euler((2.16696, -1.57161, 0.0), 'XYZ')
    y4 = mathutils.Euler((2.63809, -1.8803, 0.0), 'XYZ')
    y5 = mathutils.Euler((2.87256, -2.03382, 0.0), 'XYZ')

# left finger element
    helicity = 'left'

    start = 112
    end = start+0

    ring_left = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    ring_left.rig.location = (-0.010689, 0.001192, 0.241051)
    ring_left.rig.rotation_euler = mathutils.Euler((math.radians(-5.10153), math.radians(-1.70737), math.radians(0.02464)), 'XYZ')

# finger element
    part = 'ring-right'

# right finger element
    helicity = 'right'

    start = 126
    end = start-0

    ring_right = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)    

    ring_right.rig.location = (-0.010689, -0.001192, 0.241051)
    ring_right.rig.rotation_euler = mathutils.Euler((math.radians(180+5.10153), math.radians(-1.70737), math.radians(-0.02464)), 'XYZ')


# finger element
    part = 'little-left'
    
    y2 = mathutils.Euler((1.45986, -1.08525, 0.0), 'XYZ')
    y3 = mathutils.Euler((2.10861, -1.50077, 0.0), 'XYZ')
    y4 = mathutils.Euler((2.5324, -1.77219, 0.0), 'XYZ')
    y5 = mathutils.Euler((2.72302, -1.89418, 0.0), 'XYZ')

# left finger element
    helicity = 'left'

    start = 110
    end = start+0

    little_left = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    little_left.rig.location = (-0.020568, 0.002289, 0.463882)
    little_left.rig.rotation_euler = mathutils.Euler((math.radians(-10.1646), math.radians(-2.09755), math.radians(-0.518101)), 'XYZ')

# finger element
    part = 'little-right'

# right finger element
    helicity = 'right'

    start = 117
    end = start-0

    little_right = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    little_right.rig.location = (-0.020568, -0.002289, 0.463882)
    little_right.rig.rotation_euler = mathutils.Euler((math.radians(180+10.1646), math.radians(-2.09755), math.radians(0.518101)), 'XYZ')


# finger element
    part = 'index-left'

    y2 = mathutils.Euler((1.36561, -1.0465, 0.0), 'XYZ')
    y3 = mathutils.Euler((2.0559, -1.49887, 0.0), 'XYZ')
    y4 = mathutils.Euler((2.52701, -1.80756, 0.0), 'XYZ')
    y5 = mathutils.Euler((2.76149, -1.96108, 0.0), 'XYZ')

# left finger element
    helicity = 'left'

    start = 137.94
    end = start+0

    index_left = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    index_left.rig.location = (0.012703, -0.00141, -0.286505)
    index_left.rig.rotation_euler = mathutils.Euler((math.radians(2.53073), math.radians(2.85122), math.radians(0.320067)), 'XYZ')

# finger element
    part = 'index-right'

# right finger element
    helicity = 'right'

    start = 187
    end = start-0

    index_right = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    index_right.rig.location = (0.012703, 0.00141, -0.286505)
    index_right.rig.rotation_euler = mathutils.Euler((math.radians(180-2.53073), math.radians(2.85122), math.radians(-0.320067)), 'XYZ')


# finger element
    part = 'thumb-left'

    P = -0.075869 #pivot factor

    y2 = mathutils.Euler((0.265988, -0.219792, 0.0), 'XYZ')
    y3 = mathutils.Euler((1.0999, -0.768173, 0.0), 'XYZ')
    y4 = mathutils.Euler((1.71494, -1.17263, 0.0), 'XYZ')
    y5 = mathutils.Euler((1.97601, -1.3443, 0.0), 'XYZ')

# left finger element
    helicity = 'left'

    start = 76
    end = start+0

    thumb_left = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    thumb_left.rig.location = (0.009956, -0.090396, -0.3247)
    thumb_left.rig.rotation_euler = mathutils.Euler((math.radians(87.8968), math.radians(-3.16487), math.radians(-23.1096)), 'XYZ')

# finger element
    part = 'thumb-right'

# right finger element
    helicity = 'right'

    start = -206
    end = start+0

    thumb_right = Finger(P, A, move, part, helicity, start, end, y2, y3, y4, y5)

    thumb_right.rig.location = (0.009956, 0.090396, -0.3247)
    thumb_right.rig.rotation_euler = mathutils.Euler((math.radians(180-87.8968), math.radians(-3.16487), math.radians(23.1096)), 'XYZ')


# Parent set four fingers to middle finger
    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.scene.frame_current = 0

# left hand
    bpy.ops.object.select_all(action='DESELECT')
    middle_left.rig.select_set(state=True)
    bpy.context.view_layer.objects.active = middle_left.rig

    bpy.ops.object.editmode_toggle()

    parent_bone = 'a2a1' # choose the bone name which you want to be the parent

    middle_left.rig.data.edit_bones.active = middle_left.rig.data.edit_bones[parent_bone]

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.ops.object.select_all(action='DESELECT') #deselect all objects
    ring_left.rig.select_set(state=True)
    little_left.rig.select_set(state=True)
    index_left.rig.select_set(state=True)
    thumb_left.rig.select_set(state=True)
    middle_left.rig.select_set(state=True)
    bpy.context.view_layer.objects.active = middle_left.rig    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='BONE', keep_transform=True)

# right hand
    bpy.ops.object.select_all(action='DESELECT') #deselect all objects
    middle_right.rig.select_set(state=True)
    bpy.context.view_layer.objects.active = middle_right.rig

    bpy.ops.object.editmode_toggle()

    parent_bone = 'a2a1' # choose the bone name which you want to be the parent

    middle_right.rig.data.edit_bones.active = middle_right.rig.data.edit_bones[parent_bone]

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.ops.object.select_all(action='DESELECT') #deselect all objects
    ring_right.rig.select_set(state=True)
    little_right.rig.select_set(state=True)
    index_right.rig.select_set(state=True)
    thumb_right.rig.select_set(state=True)
    middle_right.rig.select_set(state=True)
    bpy.context.view_layer.objects.active = middle_right.rig    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='BONE', keep_transform=True)

    bpy.ops.object.select_all(action='DESELECT') #deselect all objects


def wrists():
    
# scale factor
    A = 0.351
    
# pivot factor
    P = 0

# name
    move = 'swinging-drummajor'


# wrist element
    part = 'wrist-left'

# helicity
    helicity = 'right'

    start = 0
    end = start

    fingers_loc = ((-0.998894/0.351)*A, (-0.000381/0.351)*A, (-0.349921/0.351)*A)
    fingers_rot = mathutils.Euler((math.radians(302.398), math.radians(10.1313), math.radians(688.017)), 'XYZ')

    global middle_left
    middle_finger = middle_left
    
    global wrist_left
    wrist_left = Wrist(P, A, move, part, helicity, start, end, fingers_loc, fingers_rot, middle_finger)


# right wrist element
    part = 'wrist-right'

# helicity
    helicity = 'right'

    start = 0
    end = start

    fingers_loc = (0, 0, 0)
    fingers_rot = mathutils.Euler((math.radians(94.9995), math.radians(-113.106), math.radians(-182.593)), 'XYZ')

    global middle_right
    middle_finger = middle_right
    
    global wrist_right
    wrist_right = Wrist(P, A, move, part, helicity, start, end, fingers_loc, fingers_rot, middle_finger)


def arms():

# scale factor
    A = 0.4

# pivot factor
    P = 0.0

# name
    move = 'swinging-drummajor'

# arm element
    part = 'arm-right'

# right arm element
    helicity = 'right'

    start = 0
    end = start+1440

    global wrist_right
    wrist = wrist_right

    global arm_right
#    arm_right = Arm(P, A, move, part, helicity, start, end, wrist_loc, wrist_rot, wrist)
    arm_right = Arm2(P, A, move, part, helicity, start, end)

# element
    part = 'arm-left'

# left or right
    helicity = 'right'

    start = -2679.14
    end = start+360

    global arm_left
    arm_left = LeftArm(P, A, move, part, helicity, start, end)

    global middle_left
    
    cns = arm_left.rig.pose.bones['y3y4'].constraints.new('IK')
    cns.name = 'Ik'
    cns.target = middle_left.rig
    cns.subtarget = 'b1y1'
    cns.pole_target = arm_left.rig
    cns.pole_subtarget = 'y6y7'
    cns.pole_angle = math.radians(180)
    cns.iterations = 500
    cns.chain_count = 2
    cns.use_stretch = False

    cns = arm_left.rig.pose.bones['y4y5'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = middle_left.rig
    cns.subtarget = 'a2a1'


def forewings():

# scale factor
    A = 0.138222
#    A = 0.1105776 # 0.138222*0.8 #2102.72
#    A = 0.08846208 # 0.1105776 #2102.73
    
# pivot factor
    P = 0
    
# name
    move = 'swinging-drummajor'

# element
    part = 'right-forewing'

# left or right
    helicity = 'right'

    start = -180
    end = start-720

    global arm_right
    arm = arm_right

    arm_loc = ((-1.105053/0.138222)*A, (-3.425665/0.138222)*A, (-1.312141/0.138222)*A)
    arm_rot = mathutils.Euler((math.radians(487.732), math.radians(34.9533), math.radians(-253.428)), 'XYZ')

    global forewing_right
    forewing_right = ForeWing(P, A, move, part, helicity, start, end,
            arm_loc, arm_rot, arm)


def head():

# scale factor
    A = 0.747868

# pivot factor
    P = (-0.560906/0.747868)*A
    
# name
    move = 'swinging-drummajor'

# element
    part = 'head'

# left or right
    helicity = 'left'

    start = 180
    end = start-720

    global head
    head = Head(P, A, move, part, helicity, start, end)


def neck():
    
# scale factor
    A = 0.351
    
# pivot factor
    P = 0

# name
    move = 'swinging-drummajor'

# neck element
    part = 'neck'

# helicity
    helicity = 'left'

    start = 0
    end = start

    head_loc = ((0.503375/0.351)*A, (-1.25659/0.351)*A, (0.855139/0.351)*A)
    head_rot = mathutils.Euler((math.radians(-21.9117), math.radians(95.3065), math.radians(171.009)), 'XYZ')

    global head
    
    global neck
    neck = Neck(P, A, move, part, helicity, start, end, head_loc, head_rot, head)


def shoulder():

    start = 383
    end = start-720
 
# name
    move = 'swinging-drummajor'
    
# scale factor
    A = 0.431828

# pivot factor
    P = (-0.404752/0.431828)*A

# element
    part = 'left-shoulder'

# left or right
    helicity = 'right'

    global neck

    neck_loc = ((0.865876/0.431828)*A, (0.272797/0.431828)*A, (0.036841/0.431828)*A)
    neck_rot = mathutils.Euler((math.radians(-0.787339), math.radians(183.774), math.radians(21.1636)), 'XYZ')

    global arm_left
    arm = arm_left

    arm_loc = ((0.431019/0.431828)*A, (-3.36615/0.431828)*A, 0)
    arm_rot = mathutils.Euler((math.radians(177.684), math.radians(-14.7039), math.radians(-764.148)), 'XYZ')

    global shoulder_left
    shoulder_left = LeftShoulder(P, A, move, part, helicity, start, end,
        neck_loc, neck_rot, neck, arm_loc, arm_rot, arm)

# element
    part = 'right-shoulder'

    global forewing_right
    forewing = forewing_right

    forewing_loc = ((0.427104/0.431828)*A, (4.173598/0.431828)*A, (-3.384795/0.431828)*A)
    forewing_rot = mathutils.Euler((math.radians(609.117), math.radians(8.17249), math.radians(-605.34)), 'XYZ')

    global shoulder_right
    shoulder_right = RightShoulder(P, A, move, part, helicity, start, end,
        forewing_loc, forewing_rot, forewing)


def costa():

# scale factor
    A = 0.431828

# pivot factor
    P = (-0.323882/0.431828)*A

# name
    move = 'swinging-drummajor'

# element
    part = 'costa'

# left or right
    helicity = 'left'

    start = 0
    end = start-720

    global shoulder_left
    global shoulder_right

    shoulder_loc = ((-3.514183/0.431828)*A, (-0.887314/0.431828)*A, (-0.322534/0.431828)*A)
    shoulder_rot = mathutils.Euler((math.radians(92.4575), math.radians(277.515), math.radians(87.9448)), 'XYZ')

    global costa
    costa = Costa(P, A, move, part, helicity, start, end,
        shoulder_loc, shoulder_rot, shoulder_left, shoulder_right)
#        shoulder_loc, shoulder_rot, shoulder_left, shoulder_right,
#        neck_loc, neck_rot, neck)


def legs():

# scale factor
    A = 0.351173

# pivot factor
    P = (-0.270329/0.351173)*A
    
# name
    move = 'swinging-drummajor'

# element
    part = 'leg-left'

# left or right
    helicity = 'left'

    start = -2679.14
    end = start+360

    global leg_left
    leg_left = Legs(P, A, move, part, helicity, start, end)

# element
    part = 'leg-right'

    global leg_right
    leg_right = Legs(P, A, move, part, helicity, start, end)


def heels():

# name
    move = 'swinging-drummajor'
    
# scale factor
    A = 1.87097

# pivot factor
    P = (-0.935485/(1.87097))*A

# element
    part = 'heel-right'

# left or right
    helicity = 'left'

    start = -180
    end = start-720

    global leg_right

    global heel_right
    heel_right = Heel(P, A, move, part, helicity, start, end, leg_right)

# scale factor
    A = 1.87097

# pivot factor
    P = (-0.935485/(1.87097))*A

# element
    part = 'heel-left'

# left or right
    helicity = 'left'

    start = 0
    end = start-720

    global leg_left

    global heel_left
    heel_left = Heel(P, A, move, part, helicity, start, end, leg_left)


def foots():

# name
    move = 'swinging-drummajor'

# scale factor
    A = 0.702349

# pivot factor
    P = (0.351175/0.702349)*A

# element
    part = 'foot-right'

# left or right
    helicity = 'left'

    start = 94
    end = start

    global thoracic

    global heel_right

    heel_right_loc = ((3.32349/0.702349)*A, (-0.84744/0.702349)*A, (0.367887/0.702349)*A)
    heel_right_rot = mathutils.Euler((math.radians(-90), math.radians(53.0124), math.radians(-180)), 'XYZ')

    global foot_right
    foot_right = Foot(P, A, move, part, helicity, start, end, heel_right_loc, heel_right_rot, heel_right)

    foot_right_loc = ((-6.51366/0.702349)*A, (-1.99202/0.702349)*A, (1.4955/0.702349)*A)
    foot_right_rot = mathutils.Euler((math.radians(0.0), math.radians(0.0), math.radians(145.0)), 'XYZ')

    # foot_left position
    foot_right.rig.location.x += foot_right_loc[0]
    foot_right.rig.location.y += foot_right_loc[1]
    foot_right.rig.location.z += foot_right_loc[2]

    foot_right.rig.rotation_euler = foot_right_rot

# pivot factor
    P = 0.0

# element
    part = 'foot-left'

# left or right
    helicity = 'left'

    start = 74
    end = start

    global heel_left

    heel_left_loc = ((-3.98366/0.702349)*A, (-0.793683/0.702349)*A, (0.331564/0.702349)*A)
    heel_left_rot = mathutils.Euler((math.radians(271.33), math.radians(51.6134), math.radians(-352.953)), 'XYZ')

    global foot_left
    foot_left = Foot(P, A, move, part, helicity, start, end, heel_left_loc, heel_left_rot, heel_left)

    foot_left_loc = ((7.179338/0.702349)*A, (1.558202/0.702349)*A, (1.49966/0.702349)*A)
    foot_left_rot = mathutils.Euler((math.radians(0.0), math.radians(0.0), math.radians(-65.0)), 'XYZ')

    # foot_left position
    foot_left.rig.location.x += foot_left_loc[0]
    foot_left.rig.location.y += foot_left_loc[1]
    foot_left.rig.location.z += foot_left_loc[2]

    foot_left.rig.rotation_euler = foot_left_rot


def hindwings():

# scale factor
#    A = 0.276443 #294.31
#    A = 0.2211544 #0.276443*0.8 #294.32
    A = 0.1769235 #0.2211544*0.8 #294.33

# pivot factor
    P = (-0.154808/0.276443)*A
    
# name
    move = 'swinging-drummajor'

# element
    part = 'hindwing-left'

# left or right
    helicity = 'right'

    start = -90
    end = start+720
    
    global leg_left

#    leg_loc = ((-1.10445/0.276443)*A, (-2.37762/0.276443)*A, (-4.74967/0.276443)*A) #294.31
    leg_loc = ((-0.863535/0.1769235)*A, (-1.4557/0.1769235)*A, (-3.85788/0.1769235)*A) #294.33

#    leg_rot = mathutils.Euler((math.radians(394.014), math.radians(-63.8814), math.radians(-371.401)), 'XYZ') #294.31
    leg_rot = mathutils.Euler((math.radians(473.675), math.radians(-10.6543), math.radians(-428.868)), 'XYZ') #294.33

    global hindwing_left
    hindwing_left = HindWing(P, A, move, part, helicity, start, end,
        leg_loc, leg_rot, leg_left)

# element
    part = 'hindwing-right'

# left or right
    helicity = 'left'

    start = -90
    end = start-720

    global leg_right

#    leg_loc = ((-1.14484/0.276443)*A, (-2.36831/0.276443)*A, (4.96685/0.276443)*A) #294.31
    leg_loc = ((-0.877363/0.1769235)*A, (-1.47103/0.1769235)*A, (3.84823/0.1769235)*A) #294.33

#    leg_rot = mathutils.Euler((math.radians(184.588), math.radians(56.5416), math.radians(-368.854)), 'XYZ') #294.31
    leg_rot = mathutils.Euler((math.radians(174.855), math.radians(-3.87562), math.radians(-423.576)), 'XYZ') #294.33

    global hindwing_right
    hindwing_right = HindWing(P, A, move, part, helicity, start, end,
        leg_loc, leg_rot, leg_right)


def ilium():

# scale factor
    A = 1.03339

# pivot factor
    P = (-0.516695/1.03339)*A
       
# name
    move = 'swinging-drummajor'

# element
    part = 'ilium-left'

# left or right
    helicity = 'left'

    start = -180
    end = start+720

    global hindwing_left

    hindwing = hindwing_left

    hindwing_loc = ((3.85397/1.03339)*A, (-5.61403/1.03339)*A, (4.318571/1.03339)*A)
    hindwing_rot = mathutils.Euler((math.radians(18.8539), math.radians(-58.5867), math.radians(517.932)), 'XYZ')

    global ilium_left
    ilium_left = LeftIlium(P, A, move, part, helicity, start, end, hindwing_loc, hindwing_rot, hindwing)

# element
    part = 'ilium-right'
    
    global hindwing_right
    
    hindwing = hindwing_right

    hindwing_loc = ((3.785349/1.03339)*A, (3.745785/1.03339)*A, (4.548339/1.03339)*A)
    hindwing_rot = mathutils.Euler((math.radians(-29.1362), math.radians(233.892), math.radians(32.5195)), 'XYZ')

    global ilium_right
    ilium_right = RightIlium(P, A, move, part, helicity, start, end, hindwing_loc, hindwing_rot, hindwing)


def sacrum():

# scale factor
    A = 1.03369
    
# pivot factor
    P = 0

# name
    move = 'swinging-drummajor'

# element
    part = 'sacrum'

# left or right
    helicity = 'left'

    start = 85.125
    end = start

    global ilium_left
    global ilium_right

    ilium_loc = ((-0.020076/1.03369)*A, (-0.584266/1.03369)*A, (3.351228/1.03369)*A)
    ilium_rot = mathutils.Euler((math.radians(-581.01), math.radians(95.3723), math.radians(-943.864)), 'XYZ')

    global sacrum
    sacrum = Sacrum(P, A, move, part, helicity, start, end,
        ilium_loc, ilium_rot, ilium_left, ilium_right)


def spine():

# scale factor
    A = 0.578724

# pivot factor
    P = (-0.522291/0.578724)*A
    
# name
    move = 'swinging-drummajor'

# element
    part = 'spine'

# left or right
    helicity = 'left'

    start = 115.5
    end = start
    
    global costa
    global sacrum
    
    costa_loc = ((-0.82881/0.578724)*A, (-0.225578/0.578724)*A, (0.450057/0.578724)*A)
    costa_rot = mathutils.Euler((math.radians(88.9385), math.radians(0.938303), math.radians(-53.0207)), 'XYZ')

    sacrum_loc = ((4.87996/0.578724)*A, (-3.70579/0.578724)*A, (-1.11167/0.578724)*A)
    sacrum_rot = mathutils.Euler((math.radians(-448.919), math.radians(20.2091), math.radians(216.005)), 'XYZ')

    global spine
    spine = Spine(P, A, move, part, helicity, start, end,
        costa_loc, costa_rot, costa, sacrum_loc, sacrum_rot, sacrum)


def thoracic():

# scale factor
    A = 0.539785

# pivot factor
    P = (-0.404839/0.539785)*A

# name
    move = 'swinging-drummajor'

# element
    part = 'thoracic'

# left or right
    helicity = 'left'

    start = 335.25
    end = start

    global spine

    spine_loc = ((0.146282/0.539785)*A, (-0.122517/0.539785)*A, (29.5787/0.539785)*A)
    spine_rot = mathutils.Euler((math.radians(-270.088), math.radians(36.3095), math.radians(-425.793)), 'XYZ')

    global thoracic
    thoracic = Thoracic(P, A, move, part, helicity, start, end,
        spine_loc, spine_rot, spine)

    thoracic_loc = ((1.19146/0.539785)*A, (0.458294/0.539785)*A, (0.06407/0.539785)*A)
    thoracic_rot = mathutils.Euler((math.radians(0.0), math.radians(0.0), math.radians(149.949)), 'XYZ')

    # position
    thoracic.rig.location.x += thoracic_loc[0]
    thoracic.rig.location.y += thoracic_loc[1]
    thoracic.rig.location.z += thoracic_loc[2]

    thoracic.rig.rotation_euler = thoracic_rot


def jump():

    start = 180
    end = start-720

# scale factor
    A = 1.58683

# pivot factor
    P = 0
    
# name
    move = 'equestrianism-jump'

# left or right
    helicity = 'left'

# element
    part = 'jump-right'

    global jump_right
    jump_right = Jump(P, A, move, part, helicity, start, end)

    jump_right.rig.location = ((-1.938308/1.58683)*A, (-1.498377/1.58683)*A, (1.757306/1.58683)*A)
    jump_right.rig.rotation_euler = mathutils.Euler((math.radians(270), math.radians(0), math.radians(90)), 'XYZ')

    start = 0
    end = start-720

# element
    part = 'jump-left'

    global jump_left
    jump_left = Jump(P, A, move, part, helicity, start, end)

    jump_left.rig.location = ((1.661692/1.58683)*A, (-1.498377/1.58683)*A, (1.757306/1.58683)*A)
    jump_left.rig.rotation_euler = mathutils.Euler((math.radians(270), math.radians(0), math.radians(90)), 'XYZ')

    start = -90
    end = start-1440

# scale factor
    A = 0.550982

# element
    part = 'jump-center'

    global jump_center
    jump_center = Jump(P, A, move, part, helicity, start, end)

    jump_center.rig.location = ((-0.02963/0.550982)*A, (0.079649/0.550982)*A, (1.420106/0.550982)*A)
    jump_center.rig.rotation_euler = mathutils.Euler((math.radians(270), math.radians(0), math.radians(90)), 'XYZ')
    
    
def alignment():

    # scale factor
    A = 1
    
# name
    move = 'swinging-drummajor'

# element
    part = 'alignment'

# left or right
    helicity = 'left'
    
    #
    # wrist_right
    #

    global wrist_right_alignment

    wrist_right_alignment = bpy.data.objects["alignment.000"].copy()
    wrist_right_alignment.location = (0.0, 0.0, 0.0)
#    wrist_right_alignment.location = (9.98322, 0.0, 1.49966)
    wrist_right_alignment.scale = (A, A, A)
    wrist_right_alignment.name = "wrist_right_alignment.mesh." + move + '.' + part +'.' + helicity
    bpy.data.collections['link'].objects.link(wrist_right_alignment)

    global wrist_right
    # position 
#    wrist_right_alignment.location.x += wrist_right.rig.location.x
#    wrist_right_alignment.location.y += wrist_right.rig.location.y
#    wrist_right_alignment.location.z += wrist_right.rig.location.z

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.scene.frame_current = 0

    bpy.ops.object.select_all(action='DESELECT')

    wrist_right.rig.select_set(state=True)
    wrist_right_alignment.select_set(state=True)
    bpy.context.view_layer.objects.active = wrist_right_alignment    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)
    bpy.ops.object.select_all(action='DESELECT') #deselect all objects

    global arm_right

    # wrist -> arm
    cns = wrist_right_alignment.constraints.new('COPY_LOCATION')
    cns.name = 'Copy Location'
    cns.target = arm_right.rig
    cns.subtarget = 'y4y5'
    cns.head_tail = 0.0
    cns.influence = 1.0
#    cns.use_z = False
    
#    wrist_loc = ((4.488434/0.4)*A, (0.434276/0.4)*A, 0.0)
    wrist_rot = mathutils.Euler((math.radians(268.016), math.radians(177.957), math.radians(-179.819)), 'XYZ')
    
    # disciple position
    wrist_right.rig.rotation_euler = wrist_rot

    #
    # wrist_left
    #

    global wrist_left_alignment

    wrist_left_alignment = bpy.data.objects["alignment.000"].copy()
    wrist_left_alignment.location = (0.0, 0.0, 0.0)
#    wrist_left_alignment.location = (9.98322, 0.0, 1.49966)
    wrist_left_alignment.scale = (A, A, A)
    wrist_left_alignment.name = "wrist_left_alignment.mesh." + move + '.' + part +'.' + helicity
    bpy.data.collections['link'].objects.link(wrist_left_alignment)

    global wrist_left
    # position 
#    wrist_left_alignment.location.x += wrist_left.rig.location.x
#    wrist_left_alignment.location.y += wrist_left.rig.location.y
#    wrist_left_alignment.location.z += wrist_left.rig.location.z

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.scene.frame_current = 0

    bpy.ops.object.select_all(action='DESELECT')

    wrist_left.rig.select_set(state=True)
    wrist_left_alignment.select_set(state=True)
    bpy.context.view_layer.objects.active = wrist_left_alignment    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)
    bpy.ops.object.select_all(action='DESELECT') #deselect all objects

    global ilium_left

    # wrist -> arm
    cns = wrist_left_alignment.constraints.new('COPY_LOCATION')
    cns.name = 'Copy Location'
    cns.target = ilium_left.rig
    cns.subtarget = 'y3y4'
    cns.head_tail = 1.0
    cns.influence = 1.0
#    cns.use_z = False
    
#    wrist_loc = ((4.488434/0.4)*A, (0.434276/0.4)*A, 0.0)
    wrist_rot = mathutils.Euler((math.radians(-165.06), math.radians(26.6338), math.radians(-184.501)), 'XYZ')
    
    # disciple position
    wrist_left.rig.rotation_euler = wrist_rot

    #
    # foot_left
    #

    global foot_left_alignment

    foot_left_alignment = bpy.data.objects["alignment.000"].copy()
    foot_left_alignment.location = (0.0, 0.0, 0.0)
    foot_left_alignment.scale = (A, A, A)
    foot_left_alignment.name = "foot_left_alignment.mesh." + move + '.' + part +'.' + helicity
    bpy.data.collections['link'].objects.link(foot_left_alignment)

    global foot_left
    # position 
    foot_left_alignment.location.x += foot_left.rig.location.x
    foot_left_alignment.location.y += foot_left.rig.location.y
    foot_left_alignment.location.z += foot_left.rig.location.z

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.scene.frame_current = 0

    bpy.ops.object.select_all(action='DESELECT')

    foot_left.rig.select_set(state=True)
    foot_left_alignment.select_set(state=True)
    bpy.context.view_layer.objects.active = foot_left_alignment    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)
    bpy.ops.object.select_all(action='DESELECT') #deselect all objects

    global jump_left

    # wrist -> arm
    cns = foot_left_alignment.constraints.new('COPY_LOCATION')
    cns.name = 'Copy Location'
    cns.target = jump_left.rig
    cns.subtarget = 'y1y2'
    cns.head_tail = 0.0
    cns.influence = 1.0
#    cns.use_z = False

    #
    # foot_right
    #

    global foot_right_alignment

    foot_right_alignment = bpy.data.objects["alignment.000"].copy()
    foot_right_alignment.location = (0.0, 0.0, 0.0)
    foot_right_alignment.scale = (A, A, A)
    foot_right_alignment.name = "foot_right_alignment.mesh." + move + '.' + part +'.' + helicity
    bpy.data.collections['link'].objects.link(foot_right_alignment)

    global foot_right
    # position 
    foot_right_alignment.location.x += foot_right.rig.location.x
    foot_right_alignment.location.y += foot_right.rig.location.y
    foot_right_alignment.location.z += foot_right.rig.location.z

    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.scene.frame_current = 0

    bpy.ops.object.select_all(action='DESELECT')

    foot_right.rig.select_set(state=True)
    foot_right_alignment.select_set(state=True)
    bpy.context.view_layer.objects.active = foot_right_alignment    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)
    bpy.ops.object.select_all(action='DESELECT') #deselect all objects

    global jump_right

    # wrist -> arm
    cns = foot_right_alignment.constraints.new('COPY_LOCATION')
    cns.name = 'Copy Location'
    cns.target = jump_right.rig
    cns.subtarget = 'y1y2'
    cns.head_tail = 0.0
    cns.influence = 1.0
#    cns.use_z = False

    #
    # foot_center
    #

    global thoracic_alignment

    thoracic_alignment = bpy.data.objects["alignment.000"].copy()
    thoracic_alignment.location = (0.0, 0.0, 0.0)
    thoracic_alignment.scale = (A, A, A)
    thoracic_alignment.name = "thoracic_alignment.mesh." + move + '.' + part +'.' + helicity
    bpy.data.collections['link'].objects.link(thoracic_alignment)

    global thoracic
    # position 
    thoracic_alignment.location.x += thoracic.rig.location.x
    thoracic_alignment.location.y += thoracic.rig.location.y
    thoracic_alignment.location.z += thoracic.rig.location.z
    
    bpy.ops.object.mode_set(mode='OBJECT')

    bpy.context.scene.frame_current = 0

    bpy.ops.object.select_all(action='DESELECT')

    thoracic.rig.select_set(state=True)
    thoracic_alignment.select_set(state=True)
    bpy.context.view_layer.objects.active = thoracic_alignment    #the active object will be the parent of all selected object

    bpy.ops.object.parent_set(type='OBJECT', keep_transform=True)
    bpy.ops.object.select_all(action='DESELECT') #deselect all objects

    global jump_center

    # wrist -> arm
    cns = thoracic_alignment.constraints.new('COPY_LOCATION')
    cns.name = 'Copy Location'
    cns.target = jump_center.rig
    cns.subtarget = 'y1y2'
    cns.head_tail = 0.0
    cns.influence = 1.0
#    cns.use_z = False

    #
    # baton
    #

    global baton_alignment

    baton_alignment = bpy.data.objects["alignment.000"].copy()
#    baton_alignment.location = (0.0, 0.0, 0.0)
    baton_alignment.location = (-11.6792, -4.72043, 69.7906)
    baton_alignment.scale = (A, A, A)
    baton_alignment.name = "baton_alignment.mesh." + move + '.' + part +'.' + helicity
    bpy.data.collections['link'].objects.link(baton_alignment)

    # wrist_right_alignment -> batton
    cns = wrist_right_alignment.constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = baton_alignment
    cns.track_axis = 'TRACK_Z'
    cns.influence = 1.0

def main(origin):
    
    # create new collection
    newCol = bpy.data.collections.new('movement')
    # link the newCol to the scene
    bpy.context.scene.collection.children.link(newCol)

    newCol = bpy.data.collections.new('link')
    bpy.context.scene.collection.children.link(newCol)

    global interval
    global frame_start
    global frame_end

    frame_start = 0
    frame_end = 480

    interval = frame_end - frame_start

    #formula()
    hands()
    wrists()
    arms()
    forewings()
    head()
    neck()
    shoulder()
    costa()
    legs()
    hindwings()
    ilium()
    sacrum()
    spine()
    thoracic()
    heels()
    foots()
    jump()
    alignment()


if __name__ == "__main__":
    # renaming of corrada objects
#    for ob in context.collection.objects:
#        if "joint_" in ob.name:
#            ob.name = ob.name.replace("_", ".")

    main((0.0, 0.0, 0.0))
    
