# ================
# SOFTWARE LICENSE
# ================

# The MIT License (MIT)

# Copyright (c) 2018 Yutaka Sawai (Varipon)

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:

# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.

# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

# ==============================================================
# LICENSE FOR CONTENT PROCEDURALLY GENERATED USING THIS SOFTWARE
# ==============================================================

# All content procedurally generated by this software and its permutations
# are licensed under Creative Commons Attribution By 3.0:

# https://creativecommons.org/licenses/by/3.0/


#!/usr/bin/python

import bpy
from bpy import *

import mathutils
import math
from mathutils import *
from math import *


class Formula:

    J = 18 #joint number

    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)


    def configMovement(self, P, A, J, a, b, y, o):

        mat_a = [0 for i in range(4)] # Joint α matrix
        mat_b = [0 for i in range(self.J)] # Joint β matrix
        mat_y = [0 for i in range(self.J)] # Joint γ matrix
        mat_o = [0 for i in range(self.J)] # Joint δ matrix

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        a[0] = mathutils.Euler((-A - E + (D * 0.5), -A - (D * 0.5), 0), 'XYZ')
        print ("a0 =", a[0])
        mat_a[0] = Matrix.Translation(a[0])

        a[3] = mathutils.Euler((0-a[0].x, 0-a[0].y, 0-a[0].z), 'XYZ')
        print ("a3 =", a[3])
        mat_a[3] = Matrix.Translation(a[3]) 

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        mat_y[1] = Matrix.Translation(y[1])

### pattern A

        b[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y + (A * 2), 0), 'XYZ')
        print ("b2 =", b[2])
        mat_b[2] = Matrix.Translation(b[2])

        b[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (A * 2), 0), 'XYZ')
        print ("b3 =", b[3])
        mat_b[3] = Matrix.Translation(b[3])
        
        y[2] = mathutils.Euler((a[0].x + E, a[0].y, 0), 'XYZ')
        print ("y2 =", y[2])
        mat_y[2] = Matrix.Translation(y[2])

        y[3] = mathutils.Euler((a[0].x + E - (D * 0.5), a[0].y - (D * 0.5), 0), 'XYZ')
        print ("y3 =", y[3])
        mat_y[3] = Matrix.Translation(y[3])

        o[2] = mathutils.Euler((a[0].x + E + (A * 2), a[0].y - (A * 2), 0), 'XYZ')
        print ("o2 =", o[2])
        mat_o[2] = Matrix.Translation(o[2])
        
        o[3] = mathutils.Euler((a[0].x + E - (D * 0.5) - (A * 2), a[0].y - (D * 0.5) - (A * 2), 0), 'XYZ')
        print ("o3 =", o[3])
        mat_o[3] = Matrix.Translation(o[3])

### pattern A end

        org_rot_mat = Matrix.Rotation(math.radians(0), 4, 'Z')

        # define the rotation
        rot_mat = Matrix.Rotation(math.radians(-45), 4, 'Z')   

        for j in range(2, J - 2):

            mat_y[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_y[j]

#            obj.matrix_world = mat_y[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_y[j + 2].decompose()
            y[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("y"+str(j + 2)+" = ", y[j + 2], rot, sca)

            mat_b[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_b[j]
            
#            obj.matrix_world = mat_b[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_b[j + 2].decompose()
            b[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("b"+str(j + 2)+" = ", b[j + 2], rot, sca)

            mat_o[j + 2] = mat_a[0] * org_rot_mat * rot_mat * mat_a[3] * mat_o[j]
            
#            obj.matrix_world = mat_o[j + 2]
            # extract components back out of the matrix
            loc, rot, sca = mat_o[j + 2].decompose()
            o[j + 2] = mathutils.Euler(loc, 'XYZ')
            print("o"+str(j + 2)+" = ", o[j + 2], rot, sca)


    def constructMovement(self, J, helicity, amt, rig, a, b, y, o):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-2):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]


        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')
        

    def configRotation(self, rig, interval, frame_start, frame_end, start, end):

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        # key insert 
        keyframe_insert_interval = interval

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(start) 
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_start)

        rig.pose.bones["a1b1"].rotation_mode = 'XYZ'
        rig.pose.bones["a1b1"].rotation_euler.z = math.radians(end)
        rig.pose.bones["a1b1"].keyframe_insert(data_path="rotation_euler",frame=frame_end)

        for curve in bpy.context.active_object.animation_data.action.fcurves:
            cycles = curve.modifiers.new(type='CYCLES')
            cycles.mode_before = 'REPEAT_OFFSET'
            cycles.mode_after = 'REPEAT_OFFSET'

            for keyframe in curve.keyframe_points:
                keyframe.interpolation = 'LINEAR'

        bpy.ops.object.mode_set(mode='OBJECT')


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    def constructLink(self, A, J, helicity, rig, move, part):

        # Move and rotate the tip bone in pose mode
        bpy.context.scene.objects.active = rig 

        Y = 1.1838*A

        for n in rig.pose.bones:
            if n.name != "o" + str(J-2) + "b" + str(J-1):
                # we can get the object from the pose bone
                obj = n.id_data
                matrix_final = obj.matrix_world * n.matrix

                # Create armature and object
                lnk = bpy.data.armatures.new(n.name[:len(n.name)]+'.data.' + helicity)
                lnk_rig = bpy.data.objects.new(n.name[:len(n.name)]+'.link.' + helicity, lnk)
                lnk_rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')

                # rig.show_x_ray = True
                lnk.show_names = True
                lnk.draw_type = 'STICK'

                # Link object to scene
                scn = bpy.context.scene
                scn.objects.link(lnk_rig)
                scn.objects.active = lnk_rig
                scn.update()

                # Create bones

                # mode='EDIT'
                bpy.ops.object.editmode_toggle()
    
                link = lnk.edit_bones.new(n.name[:len(n.name)])
                link.head = (0, 0, 0)
                link.tail = (0, Y, 0)

                link_head = lnk.edit_bones.new('head')
                link_head.head = (0, 0, 0.1)
                link_head.tail = (0, 0, 0)
                link_head.parent = link
                link_head.use_inherit_scale = False

                link_tail = lnk.edit_bones.new('tail')
                link_tail.head = (0, Y, 0)
                link_tail.tail = (0, Y, -0.1)
                link_tail.parent = link
                link_tail.use_inherit_scale = False

                bpy.ops.object.mode_set(mode='OBJECT')

                ob = bpy.data.objects[n.name[:len(n.name)]+'.mesh.' + move + '.' + part +'.' + helicity]
                ob.location = mathutils.Euler((0, 0, 0), 'XYZ')
    
                # Give mesh object an armature modifier, using vertex groups but
                # not envelopes
                mod = ob.modifiers.new('MyRigModif', 'ARMATURE')
                mod.object = lnk_rig
                mod.use_bone_envelopes = False
                mod.use_vertex_groups = True

                # Bone constraints. Armature must be in pose mode.
                bpy.ops.object.mode_set(mode='POSE')
 
                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_LOCATION')
                cns.name = 'Copy_Location'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # Copy rotation constraints Base -> Tip
                pBase = lnk_rig.pose.bones[n.name[:len(n.name)]]
                cns = pBase.constraints.new('COPY_ROTATION')
                cns.name = 'Copy_Rotation'
                cns.target = rig
                cns.subtarget = n.name[:len(n.name)]
                cns.owner_space = 'WORLD'
                cns.target_space = 'WORLD'

                # StretchTo constraint Mid -> Tip with influence 0.5
                cns1 = pBase.constraints.new('STRETCH_TO')
                cns1.name = 'Stretch'
                cns1.target = rig
                cns1.subtarget = n.name[:len(n.name)]
                cns1.head_tail = 1
                cns1.rest_length = Y
                cns1.influence = 1
                cns1.keep_axis = 'PLANE_Z'
                cns1.volume = 'NO_VOLUME'

                bpy.ops.object.mode_set(mode='OBJECT')


class Pitch(Formula):

    J = 2 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
        body_loc, body_rot, body):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # body
        self.body_loc = body_loc
        self.body_rot = body_rot

        self.body = body

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n]
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y)

        # Parent body to pitch
        self.setParent(self.helicity, self.move, self.rig, self.body_loc, self.body_rot, self.body)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.3, self.J, self.helicity, self.rig, self.move, self.part)


    def configMovement(self, P, A, J, a, b, y):

        mat_a = [0 for i in range(4)] # Joint α matrix
        mat_b = [0 for i in range(self.J)] # Joint β matrix
        mat_y = [0 for i in range(self.J)] # Joint γ matrix

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        mat_y[1] = Matrix.Translation(y[1])


    def constructMovement(self, J, helicity, amt, rig, a, b, y):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')            

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.A"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        n = 1
        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    # Parent set fingers to arm        
    def setParent(self, helicity, move, rig, 
        body_loc, body_rot, body):

        # body position
        body.rig.location = body_loc
        body.rig.rotation_euler = body_rot

        # body to pitch
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select = True
        bpy.context.scene.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'b1y1' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        body.rig.select = True

        rig.select = True
        bpy.context.scene.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects
        # end
        

class Body(Formula):
    
    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end, 
            arm_left_loc, arm_left_rot, arm_left,
            arm_right_loc, arm_right_rot, arm_right):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        self.arm_left_loc = arm_left_loc
        self.arm_left_rot = arm_left_rot
        self.arm_left = arm_left

        self.arm_right_loc = arm_right_loc
        self.arm_right_rot = arm_right_rot
        self.arm_right = arm_right

        # Centroid
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.a = [0 for i in range(3)] # Joint α
        self.b = [0 for i in range(2)] # Joint β
        self.y = [0 for i in range(2)] # Joint γ
        self.o = [0 for i in range(2)] # Joint δ

        # Upper body
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.upper_b = [0 for i in range(self.J)] # Joint β
        self.upper_y = [0 for i in range(self.J)] # Joint γ
        self.upper_o = [0 for i in range(self.J)] # Joint δ

        # Joints ω(n) -> w[n]
        self.upper_w = [0 for i in range(self.J)] # Joint ω

        # Left shoulder
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.upper_left_b = [0 for i in range(self.J)] # Joint β
        self.upper_left_y = [0 for i in range(self.J)] # Joint γ
        self.upper_left_o = [0 for i in range(self.J)] # Joint δ

        self.upper_left_w = [0 for i in range(self.J)] # Joint ω matrix

        # Right shoulder
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.upper_right_b = [0 for i in range(self.J)] # Joint β
        self.upper_right_y = [0 for i in range(self.J)] # Joint γ
        self.upper_right_o = [0 for i in range(self.J)] # Joint δ

        self.upper_right_w = [0 for i in range(self.J)] # Joint ω matrix

        # Lower body
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.lower_b = [0 for i in range(self.J)] # Joint β
        self.lower_y = [0 for i in range(self.J)] # Joint γ
        self.lower_o = [0 for i in range(self.J)] # Joint δ

        # Joints ω(n) -> w[n]
        self.lower_w = [0 for i in range(self.J)] # Joint ω

        # Left leg
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]        
        self.lower_left_b = [0 for i in range(self.J)] # Joint β
        self.lower_left_y = [0 for i in range(self.J)] # Joint γ
        self.lower_left_o = [0 for i in range(self.J)] # Joint δ

        # Right leg
        # Joints α(n) -> a[n], β(n) -> b[n], γ(n) -> y[n], δ(n) -> o[n]
        self.lower_right_b = [0 for i in range(self.J)] # Joint β
        self.lower_right_y = [0 for i in range(self.J)] # Joint γ
        self.lower_right_o = [0 for i in range(self.J)] # Joint δ
        
        # gimbal
        self.gimbal_lower_left_o = [0 for i in range(self.J)] # Joint δ
        self.gimbal_lower_left_b = [0 for i in range(self.J)] # Joint β
        self.gimbal_lower_left_y = [0 for i in range(self.J)] # Joint γ
        
        self.gimbal_lower_right_o = [0 for i in range(self.J)] # Joint δ
        self.gimbal_lower_right_b = [0 for i in range(self.J)] # Joint β
        self.gimbal_lower_right_y = [0 for i in range(self.J)] # Joint γ

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o, 
            self.upper_b, self.upper_y, self.upper_o, self.upper_w,
            self.upper_left_b, self.upper_left_y, self.upper_left_o,
            self.upper_right_b, self.upper_right_y, self.upper_right_o,
            self.lower_b, self.lower_y, self.lower_o, self.lower_w,
            self.lower_left_b, self.lower_left_y, self.lower_left_o,
            self.lower_right_b, self.lower_right_y, self.lower_right_o,
            self.gimbal_lower_left_o, self.gimbal_lower_left_b, self.gimbal_lower_left_y,
            self.gimbal_lower_right_o, self.gimbal_lower_right_b, self.gimbal_lower_right_y)

        # Construction Movement
        self.constructMovement(self.J, self.amt, self.rig, 
            self.a, self.b, self.y, self.o,
            self.upper_b, self.upper_y, self.upper_o, self.upper_w,
            self.upper_left_b, self.upper_left_y, self.upper_left_o,
            self.upper_right_b, self.upper_right_y, self.upper_right_o,
            self.lower_b, self.lower_y, self.lower_o, self.lower_w,
            self.lower_left_b, self.lower_left_y, self.lower_left_o,
            self.lower_right_b, self.lower_right_y, self.lower_right_o,
            self.gimbal_lower_left_o, self.gimbal_lower_left_b, self.gimbal_lower_left_y,
            self.gimbal_lower_right_o, self.gimbal_lower_right_b, self.gimbal_lower_right_y)

        # Parent set arms to body        
        self.setParent(self.helicity, self.move, self.rig, 
            self.arm_left_loc, self.arm_left_rot, self.arm_left,
            self.arm_right_loc, self.arm_right_rot, self.arm_right)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        self.configLink(self.A*0.7, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A*0.7, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o,
            upper_b, upper_y, upper_o, upper_w,
            upper_left_b, upper_left_y, upper_left_o,
            upper_right_b, upper_right_y, upper_right_o,
            lower_b, lower_y, lower_o, lower_w,
            lower_left_b, lower_left_y, lower_left_o,
            lower_right_b, lower_right_y, lower_right_o,
            gimbal_lower_left_o, gimbal_lower_left_b, gimbal_lower_left_y,
            gimbal_lower_right_o, gimbal_lower_right_b, gimbal_lower_right_y):
        
        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])


        lower_b[2] = mathutils.Euler((1.35031, -1.93408, 0), 'XYZ')
        print ("b2.lower =", lower_b[2])

        lower_o[2] = mathutils.Euler((-1.18173, -3.18999, 0), 'XYZ')
        print ("o2.lower =", lower_o[2])

        lower_y[2] = mathutils.Euler((-0.761987, -3.11885, 0), 'XYZ')
        print ("y2.lower =", lower_y[2])

        lower_y[3] = mathutils.Euler((-0.425565, -8.51839, 0), 'XYZ')
        print ("y3.lower =", lower_y[3])

        lower_w[1] = mathutils.Euler((-0.425565, -8.51839, 2.50277), 'XYZ')
        print ("w1.lower =", lower_w[1])

        
        lower_left_o[3] = mathutils.Euler((1.76787, -8.43042, 1.81914), 'XYZ')
        print ("o3.lower.left =", lower_left_o[3])

        lower_left_b[4] = mathutils.Euler((1.76787, -19.2299, 5.0545), 'XYZ')
        print ("b4.lower.left =", lower_left_b[4])
        
        lower_left_y[4] = mathutils.Euler((1.76787, -27.4568, 2.13126), 'XYZ')
        print ("y4.lower.left =", lower_left_y[4])

        lower_left_y[5] = mathutils.Euler((1.76787, -29.0398, 4.39707), 'XYZ')
        print ("y5.lower.left =", lower_left_y[5])
        
        gimbal_lower_left_o[3] = mathutils.Euler((1.87361, -8.51839, 2.50277), 'XYZ')
        print ("o3.gimbal.lower.left =", gimbal_lower_left_o[3])

        gimbal_lower_left_b[4] = mathutils.Euler((1.87361, -19.7847, 2.50277), 'XYZ')
        print ("b4.gimbal.lower.left =", gimbal_lower_left_b[4])


        gimbal_lower_left_o[4] = mathutils.Euler((1.77335, -8.4289, 1.81649), 'XYZ')
        print ("o4.gimbal.lower.left =", gimbal_lower_left_o[4])

        gimbal_lower_left_b[5] = mathutils.Euler((5.14961, -19.1839, 1.81649), 'XYZ')
        print ("b5.gimbal.lower.left =", gimbal_lower_left_b[5])

        gimbal_lower_left_y[5] = mathutils.Euler((2.33473, -27.4476, 1.81649), 'XYZ')
        print ("y5.gimbal.lower.left =", gimbal_lower_left_y[5])

        gimbal_lower_left_y[6] = mathutils.Euler((2.91482, -27.429, 1.81649), 'XYZ')
        print ("y6.gimbal.lower.left =", gimbal_lower_left_y[6])


        lower_right_o[3] = mathutils.Euler((-2.89871, -8.60219, 1.75624), 'XYZ')
        print ("o3.lower.right =", lower_right_o[3])

        lower_right_b[4] = mathutils.Euler((-2.89871, -19.3735, 5.04104), 'XYZ')
        print ("b4.lower.right =", lower_right_b[4])
        
        lower_right_y[4] = mathutils.Euler((-2.89871, -27.5528, 1.98242), 'XYZ')
        print ("y4.lower.right =", lower_right_y[4])

        lower_right_y[5] = mathutils.Euler((-2.89871, -29.1751, 4.22026), 'XYZ')
        print ("y5.lower.right =", lower_right_y[5])

        gimbal_lower_right_o[3] = mathutils.Euler((-3.01028, -8.51839, 2.50277), 'XYZ')
        print ("o3.gimbal.lower.right =", gimbal_lower_right_o[3])

        gimbal_lower_right_b[4] = mathutils.Euler((-3.01028, -19.7726, 2.50277), 'XYZ')
        print ("b4.gimbal.lower.right =", gimbal_lower_right_b[4])


        gimbal_lower_right_o[4] = mathutils.Euler((-2.89871, -8.60219, 1.75624), 'XYZ')
        print ("o4.gimbal.lower.right =", gimbal_lower_right_o[4])

        gimbal_lower_right_b[5] = mathutils.Euler((-6.82237, -19.1528, 1.75624), 'XYZ')
        print ("b5.gimbal.lower.right =", gimbal_lower_right_b[5])

        gimbal_lower_right_y[5] = mathutils.Euler((-4.35508, -27.5285, 1.75624), 'XYZ')
        print ("y5.gimbal.lower.right =", gimbal_lower_right_y[5])

        gimbal_lower_right_y[6] = mathutils.Euler((-4.88072, -27.5137, 1.75624), 'XYZ')
        print ("y6.gimbal.lower.right =", gimbal_lower_right_y[6])


        upper_b[2] = mathutils.Euler((0.510293, 5.22315, 0), 'XYZ')
        print ("b2.upper =", upper_b[2])

        upper_o[2] = mathutils.Euler((-1.65578, 4.62023, 0), 'XYZ')
        print ("o2.upper =", upper_o[2])
        
        upper_y[2] = mathutils.Euler((-1.56747, 4.00093, 0), 'XYZ')
        print ("y2.upper =", upper_y[2])
        
        upper_w[3] = mathutils.Euler((-1.56747, 4.00093, 9.05079), 'XYZ')
        print ("w3.upper =", upper_w[3])

        upper_w[4] = mathutils.Euler((-1.65459, 3.99465, 9.05079), 'XYZ')
        print ("w4.upper =", upper_w[4])

        upper_w[5] = mathutils.Euler((-1.65459, 3.99465, 1.61675), 'XYZ')
        print ("w5.upper =", upper_w[5])


        upper_y[3] = mathutils.Euler((-1.65459, 4.6204, 0), 'XYZ')
        print ("y3.upper.left =", upper_y[3])

        upper_w[2] = mathutils.Euler((-1.65459, 4.6204, 9.05079), 'XYZ')
        print ("w2.upper =", upper_w[2])

        upper_o[3] = mathutils.Euler((-2.07892, 9.71201, 0), 'XYZ')
        print ("o3.upper =", upper_o[3])

        upper_w[1] = mathutils.Euler((-2.07852, 9.71278, 0.712845), 'XYZ')
        print ("w1.upper =", upper_w[1])

        upper_b[4] = mathutils.Euler((-2.07852, 10.4327, 0.669667), 'XYZ')
        print ("o3.upper =", upper_o[3])
        

        upper_left_y[3] = mathutils.Euler((-1.65578, 4.62023, 0), 'XYZ')
        print ("y3.upper.left =", upper_left_y[3])

        upper_left_b[3] = mathutils.Euler((1.84964, 4.81322, 0), 'XYZ')
        print ("b3.upper.left =", upper_left_b[3])

        upper_left_y[2] = mathutils.Euler((-1.56747, 3.99717, 0), 'XYZ')
        print ("y2.upper.left =", upper_left_y[2])

        upper_left_o[2] = mathutils.Euler((2.0891, 4.23926, 0), 'XYZ')
        print ("o2.upper.left =", upper_left_o[2])

#        upper_left_w[1] = mathutils.Euler((2.52833, 3.67482, 0), 'XYZ')
#        print ("w1.upper.left =", upper_left_w[1])

#        upper_left_w[2] = mathutils.Euler((1.49581, 3.75702, 2.28162), 'XYZ')
#        print ("w2.upper.left =", upper_left_w[2])
        
#        upper_left_w[3] = mathutils.Euler((0.480431, 3.83787, 4.52539), 'XYZ')
#        print ("w3.upper.left =", upper_left_w[3])

#        upper_left_w[4] = mathutils.Euler((-0.54352, 3.9194, 6.78809), 'XYZ')
#        print ("w4.upper.left =", upper_left_w[4])

#        upper_left_w[5] = mathutils.Euler((2.28863, 3.62687, 0), 'XYZ')
#        print ("w5.upper.left =", upper_left_w[5])

#        upper_left_w[6] = mathutils.Euler((2.28863, 3.62687, 4.96987), 'XYZ')
#        print ("w6.upper.left =", upper_left_w[6])
        

        upper_right_y[3] = mathutils.Euler((-1.65578, 4.62023, 0), 'XYZ')
        print ("y3.upper.right =", upper_right_y[3])

        upper_right_b[3] = mathutils.Euler((-5.25711, 3.84599, 0), 'XYZ')
        print ("b3.upper.right =", upper_right_b[3])

        upper_right_y[2] = mathutils.Euler((-1.56747, 3.99717, 0), 'XYZ')
        print ("y2.upper.right =", upper_right_y[2])

        upper_right_o[2] = mathutils.Euler((-5.17039, 3.22555, 0), 'XYZ')
        print ("o2.upper.right =", upper_right_o[2])

#        upper_right_w[1] = mathutils.Euler((-5.28344, 2.59559, 0), 'XYZ')
#        print ("w1.upper.right =", upper_right_w[1])

#        upper_right_w[2] = mathutils.Euler((-4.36226, 2.94397, 2.24368), 'XYZ')
#        print ("w2.upper.right =", upper_right_w[2])
        
#        upper_right_w[3] = mathutils.Euler((-3.42546, 3.29826, 4.52539), 'XYZ')
#        print ("w3.upper.right =", upper_right_w[3])

#        upper_right_w[4] = mathutils.Euler((-2.49646, 3.64959, 6.78809), 'XYZ')
#        print ("w4.upper.right =", upper_right_w[4])

#        upper_right_w[5] = mathutils.Euler((-5.37016, 2.58956, 0), 'XYZ')
#        print ("w5.upper.right =", upper_right_w[5])

#        upper_right_w[6] = mathutils.Euler((-5.37016, 2.58956, 4.94216), 'XYZ')
#        print ("w6.upper.right =", upper_right_w[6])


    def constructMovement(self, J, amt, rig, a, b, y, o,
            upper_b, upper_y, upper_o, upper_w,
            upper_left_b, upper_left_y, upper_left_o,
            upper_right_b, upper_right_y, upper_right_o,
            lower_b, lower_y, lower_o, lower_w,
            lower_left_b, lower_left_y, lower_left_o,
            lower_right_b, lower_right_y, lower_right_o,
            gimbal_lower_left_o, gimbal_lower_left_b, gimbal_lower_left_y,
            gimbal_lower_right_o, gimbal_lower_right_b, gimbal_lower_right_y):

        # Linkages
        aa = [[0 for i in range(3)] for j in range(3)] # Link α(i) - α(j)
        ab = [[0 for i in range(3)] for j in range(3)] # Link α(i) - β(j)
        ya = [[0 for i in range(3)] for j in range(3)] # Link γ(i) - α(j)
        ao = [[0 for i in range(3)] for j in range(3)] # Link α(i) - δ(j)
        by = [[0 for i in range(2)] for j in range(2)] # Link β(i) - γ(j)

        upper_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        upper_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        upper_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        upper_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        upper_ow = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        upper_ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        upper_left_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        upper_left_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        upper_left_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        upper_left_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        
#        upper_left_ow = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - ω(j)
#        upper_left_ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link ω(i) - ω(j)

        upper_right_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        upper_right_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        upper_right_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        upper_right_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

#        upper_right_ow = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - ω(j)
#        upper_right_ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link ω(i) - ω(j)

        lower_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        lower_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        lower_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        lower_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)

        lower_yw = [[0 for i in range(2)] for j in range(self.J)] # Link γ(i) - ω(j)

        lower_left_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        lower_left_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        lower_left_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        lower_left_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)

        lower_right_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        lower_right_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        lower_right_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        lower_right_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)

        gimbal_lower_left_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        gimbal_lower_left_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        gimbal_lower_left_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        gimbal_lower_left_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        gimbal_lower_right_yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        gimbal_lower_right_ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)

        gimbal_lower_right_by = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        gimbal_lower_right_yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)


#        gimbal_upper_left_ow = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - ω(j)
#        gimbal_upper_left_ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - ω(j)

#        gimbal_upper_right_ow = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - ω(j)
#        gimbal_upper_right_ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - ω(j)


        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        j = 1

        # Construction Linkage
        aa[j+1][j] = amt.edit_bones.new('a'+ str(j+1)+'a'+ str(j))
        aa[j+1][j].head = a[j+1]
        aa[j+1][j].tail = a[j]
#       aa[j+1][j].parent = by[j][j]_body
        
        ab[j][j] = amt.edit_bones.new('a'+ str(j)+'b'+ str(j))
        ab[j][j].head = a[j]
        ab[j][j].tail = b[j]
        ab[j][j].parent = aa[j+1][j]
 
        by[j][j] = amt.edit_bones.new('b'+ str(j)+'y'+ str(j))
        by[j][j].head = b[j]
        by[j][j].tail = y[j]
        by[j][j].parent = ab[j][j]
        by[j][j].use_inherit_rotation = False

        ya[j][j+1] = amt.edit_bones.new('y'+ str(j)+'a'+ str(j+1))
        ya[j][j+1].head = y[j]
        ya[j][j+1].tail = a[j+1]
        ya[j][j+1].parent = by[j][j]

        ao[j+1][j] = amt.edit_bones.new('a'+ str(j+1)+'o'+str(j))
        ao[j+1][j].head = a[j+1]
        ao[j+1][j].tail = o[j]
        ao[j+1][j].parent = ya[j][j+1]

        lower_ob[j][j+1] = amt.edit_bones.new('o'+ str(j)+'b'+ str(j+1)+'.lower')
        lower_ob[j][j+1].head = o[j]
        lower_ob[j][j+1].tail = lower_b[j+1]
        lower_ob[j][j+1].parent = ao[j+1][j]

        lower_yy[j][j+1] = amt.edit_bones.new('y'+ str(j)+'y'+ str(j+1)+'.lower')
        lower_yy[j][j+1].head = y[j]
        lower_yy[j][j+1].tail = lower_y[j+1]
        lower_yy[j][j+1].parent = by[j][j]
                
        upper_ob[j][j+1] = amt.edit_bones.new('o'+ str(j)+'b'+ str(j+1)+'.upper')
        upper_ob[j][j+1].head = o[j]
        upper_ob[j][j+1].tail = upper_b[j+1]
        upper_ob[j][j+1].parent = ao[j+1][j]

        upper_yy[j][j+1] = amt.edit_bones.new('y'+ str(j)+'y'+ str(j+1)+'.upper')
        upper_yy[j][j+1].head = y[j]
        upper_yy[j][j+1].tail = upper_y[j+1]
        upper_yy[j][j+1].parent = by[j][j]


        j = 2

        lower_by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j) + '.lower')
        lower_by[j][j].head = lower_b[j]
        lower_by[j][j].tail = lower_y[j]
        lower_by[j][j].parent = lower_ob[j-1][j]

        lower_yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1) + '.lower')
        lower_yy[j][j+1].head = lower_y[j]
        lower_yy[j][j+1].tail = lower_y[j+1]
        lower_yy[j][j+1].parent = lower_by[j][j]

        lower_yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j) + '.lower')
        lower_yo[j][j].head = lower_y[j]
        lower_yo[j][j].tail = lower_o[j]
        lower_yo[j][j].parent = lower_yy[j-1][j]

        upper_by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j) + '.upper')
        upper_by[j][j].head = upper_b[j]
        upper_by[j][j].tail = upper_y[j]
        upper_by[j][j].parent = upper_ob[j-1][j]

        upper_yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1) + '.upper')
        upper_yy[j][j+1].head = upper_y[j]
        upper_yy[j][j+1].tail = upper_y[j+1]
        upper_yy[j][j+1].parent = upper_by[j][j]
        
        # upper w2w3
#        upper_ww[j][j+1] = amt.edit_bones.new('w'+ str(j) + 'w'+ str(j+1) + '.upper')
#        upper_ww[j][j+1].head = upper_w[j]
#        upper_ww[j][j+1].tail = upper_w[j+1]
##        upper_ww[j][j+1].parent = upper_yy[j][j+1]

        # left shoulder gimbal
        upper_left_yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j) + '.upper.left')
        upper_left_yo[j][j].head = upper_y[j]
        upper_left_yo[j][j].tail = upper_left_o[j]
        upper_left_yo[j][j].parent = upper_yy[j-1][j]

        upper_left_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.upper.left')
        upper_left_ob[j][j+1].head = upper_left_o[j]
        upper_left_ob[j][j+1].tail = upper_left_b[j+1]
        upper_left_ob[j][j+1].parent = upper_left_yo[j][j]

        # gimbal o2w5
#        gimbal_upper_left_ow[j][j+3] = amt.edit_bones.new('o' + str(j) + 'w'+ str(j+3) + '.gimbal.upper.left')
#        gimbal_upper_left_ow[j][j+3].head = upper_left_o[j]
#        gimbal_upper_left_ow[j][j+3].tail = upper_left_w[j+3]
#        gimbal_upper_left_ow[j][j+3].parent = upper_left_ob[j][j+1]

#        upper_left_ow[j][j-1] = amt.edit_bones.new('o' + str(j) + 'w'+ str(j-1) + '.upper.left')
#        upper_left_ow[j][j-1].head = upper_left_o[j]
#        upper_left_ow[j][j-1].tail = upper_left_w[j-1]
#        upper_left_ow[j][j-1].parent = upper_left_ob[j][j+1]

        # w1w3
#        upper_left_ww[j-1][j+1] = amt.edit_bones.new('w' + str(j-1) + 'w'+ str(j+1) + '.upper.left')
#        upper_left_ww[j-1][j+1].head = upper_left_w[j-1]
#        upper_left_ww[j-1][j+1].tail = upper_left_w[j+1]
#        upper_left_ww[j-1][j+1].parent = upper_left_ow[j][j-1]

        # left w3w2
#        upper_left_ww[j+1][j] = amt.edit_bones.new('w' + str(j+1) + 'w'+ str(j) + '.upper.left')
#        upper_left_ww[j+1][j].head = upper_w[j+1]
#        upper_left_ww[j+1][j].tail = upper_left_w[j]
#        upper_left_ww[j+1][j].parent = upper_ww[j][j+1]

        # left w2w1
#        upper_left_ww[j][j-1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j-1) + '.upper.left')
#        upper_left_ww[j][j-1].head = upper_left_w[j]
#        upper_left_ww[j][j-1].tail = upper_left_w[j-1]
#        upper_left_ww[j][j-1].parent = upper_left_ww[j+1][j]

        # left gimbal w2w4
#        gimbal_upper_left_ww[j][j+2] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+2) +'.gimbal.upper.left')
#        gimbal_upper_left_ww[j][j+2].head = upper_w[j]
#        gimbal_upper_left_ww[j][j+2].tail = upper_w[j+2]
#        gimbal_upper_left_ww[j][j+2].parent = upper_ww[j][j+1]


        # right shoulder gimbal
        upper_right_yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j) + '.upper.right')
        upper_right_yo[j][j].head = upper_y[j]
        upper_right_yo[j][j].tail = upper_right_o[j]
        upper_right_yo[j][j].parent = upper_yy[j-1][j]

        upper_right_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.upper.right')
        upper_right_ob[j][j+1].head = upper_right_o[j]
        upper_right_ob[j][j+1].tail = upper_right_b[j+1]
        upper_right_ob[j][j+1].parent = upper_right_yo[j][j]

        # gimbal o2w5
#        gimbal_upper_right_ow[j][j+3] = amt.edit_bones.new('o' + str(j) + 'w'+ str(j+3) + '.gimbal.upper.right')
#        gimbal_upper_right_ow[j][j+3].head = upper_right_o[j]
#        gimbal_upper_right_ow[j][j+3].tail = upper_right_w[j+3]
#        gimbal_upper_right_ow[j][j+3].parent = upper_right_ob[j][j+1]

#        upper_right_ow[j][j-1] = amt.edit_bones.new('o' + str(j) + 'w'+ str(j-1) + '.upper.right')
#        upper_right_ow[j][j-1].head = upper_right_o[j]
#        upper_right_ow[j][j-1].tail = upper_right_w[j-1]
#        upper_right_ow[j][j-1].parent = upper_right_ob[j][j+1]

        # w1w3
#        upper_right_ww[j-1][j+1] = amt.edit_bones.new('w' + str(j-1) + 'w'+ str(j+1) + '.upper.right')
#        upper_right_ww[j-1][j+1].head = upper_right_w[j-1]
#        upper_right_ww[j-1][j+1].tail = upper_right_w[j+1]
#        upper_right_ww[j-1][j+1].parent = upper_right_ow[j][j-1]
        
        # right w3w2
#        upper_right_ww[j+1][j] = amt.edit_bones.new('w' + str(j+1) + 'w'+ str(j) + '.upper.right')
#        upper_right_ww[j+1][j].head = upper_w[j+1]
#        upper_right_ww[j+1][j].tail = upper_right_w[j]
#        upper_right_ww[j+1][j].parent = upper_ww[j][j+1]

        # right w2w1
#        upper_right_ww[j][j-1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j-1) + '.upper.right')
#        upper_right_ww[j][j-1].head = upper_right_w[j]
#        upper_right_ww[j][j-1].tail = upper_right_w[j-1]
#        upper_right_ww[j][j-1].parent = upper_right_ww[j+1][j]

        # right gimbal w2w4
#        gimbal_upper_right_ww[j][j+2] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+2) +'.gimbal.upper.right')
#        gimbal_upper_right_ww[j][j+2].head = upper_w[j]
#        gimbal_upper_right_ww[j][j+2].tail = upper_w[j+2]
#        gimbal_upper_right_ww[j][j+2].parent = upper_ww[j][j+1]


        j = 3

        lower_yw[j][1] = amt.edit_bones.new('y'+ str(j) + 'w'+ str(1) + '.lower')
        lower_yw[j][1].head = lower_y[j]
        lower_yw[j][1].tail = lower_w[1]
        lower_yw[j][1].parent = lower_yy[2][j]


        lower_left_yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j) + '.lower.left')
        lower_left_yo[j][j].head = lower_w[1]
        lower_left_yo[j][j].tail = lower_left_o[j]
        lower_left_yo[j][j].parent = lower_yw[j][1]

        lower_left_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.lower.left')
        lower_left_ob[j][j+1].head = lower_left_o[j]
        lower_left_ob[j][j+1].tail = lower_left_b[j+1]
        lower_left_ob[j][j+1].parent = lower_left_yo[j][j]


        lower_right_yo[j][j] = amt.edit_bones.new('y' + str(j) + 'o'+ str(j) +'.lower.right')
        lower_right_yo[j][j].head = lower_w[1]
        lower_right_yo[j][j].tail = lower_right_o[j]
        lower_right_yo[j][j].parent = lower_yw[j][1]

        lower_right_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) +'.lower.right')
        lower_right_ob[j][j+1].head = lower_right_o[j]
        lower_right_ob[j][j+1].tail = lower_right_b[j+1]
        lower_right_ob[j][j+1].parent = lower_right_yo[j][j]

        # gimbal
        gimbal_lower_left_yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j) + '.gimbal.lower.left')
        gimbal_lower_left_yo[j][j].head = lower_w[1]
        gimbal_lower_left_yo[j][j].tail = gimbal_lower_left_o[j]
        gimbal_lower_left_yo[j][j].parent = lower_yw[j][1]

        gimbal_lower_left_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.gimbal.lower.left')
        gimbal_lower_left_ob[j][j+1].head = gimbal_lower_left_o[j]
        gimbal_lower_left_ob[j][j+1].tail = gimbal_lower_left_b[j+1]
        gimbal_lower_left_ob[j][j+1].parent = gimbal_lower_left_yo[j][j]

        gimbal_lower_right_yo[j][j] = amt.edit_bones.new('y' + str(j) + 'o'+ str(j) +'.gimbal.lower.right')
        gimbal_lower_right_yo[j][j].head = lower_w[1]
        gimbal_lower_right_yo[j][j].tail = gimbal_lower_right_o[j]
        gimbal_lower_right_yo[j][j].parent = lower_yw[j][1]

        gimbal_lower_right_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) +'.gimbal.lower.right')
        gimbal_lower_right_ob[j][j+1].head = gimbal_lower_right_o[j]
        gimbal_lower_right_ob[j][j+1].tail = gimbal_lower_right_b[j+1]
        gimbal_lower_right_ob[j][j+1].parent = gimbal_lower_right_yo[j][j]
        # end

        upper_left_by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j) + '.upper.left')
        upper_left_by[j][j].head = upper_left_b[j]
        upper_left_by[j][j].tail = upper_left_y[j]
        upper_left_by[j][j].parent = upper_left_ob[j-1][j]
        
        upper_right_by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j) + '.upper.right')
        upper_right_by[j][j].head = upper_right_b[j]
        upper_right_by[j][j].tail = upper_right_y[j]
        upper_right_by[j][j].parent = upper_right_ob[j-1][j]


        upper_yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j) + '.upper')
        upper_yo[j][j].head = upper_y[j]
        upper_yo[j][j].tail = upper_o[j]
        upper_yo[j][j].parent = upper_yy[j-1][j]

        upper_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.upper')
        upper_ob[j][j+1].head = upper_w[1]
        upper_ob[j][j+1].tail = upper_b[j+1]
        upper_ob[j][j+1].parent = upper_yo[j][j]


#        upper_left_ww[j][j+1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+1) + '.upper.left')
#        upper_left_ww[j][j+1].head = upper_left_w[j]
#        upper_left_ww[j][j+1].tail = upper_left_w[j+1]
#        upper_left_ww[j][j+1].parent = upper_left_ww[j-2][j]

#        upper_right_ww[j][j+1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+1) + '.upper.right')
#        upper_right_ww[j][j+1].head = upper_right_w[j]
#        upper_right_ww[j][j+1].tail = upper_right_w[j+1]
#        upper_right_ww[j][j+1].parent = upper_right_ww[j-2][j]


        j = 4

        lower_left_by[j][j] = amt.edit_bones.new('b' + str(j) + 'y' + str(j) +'.lower.left')
        lower_left_by[j][j].head = lower_left_b[j]
        lower_left_by[j][j].tail = lower_left_y[j]
        lower_left_by[j][j].parent = lower_left_ob[j-1][j]

        lower_left_yy[j][j+1] = amt.edit_bones.new('y' + str(j) + 'y' + str(j+1) +'.lower.left')
        lower_left_yy[j][j+1].head = lower_left_y[j]
        lower_left_yy[j][j+1].tail = lower_left_y[j+1]
        lower_left_yy[j][j+1].parent = lower_left_by[j][j]

        # gimbal o4b5
        gimbal_lower_left_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.gimbal.lower.left')
        gimbal_lower_left_ob[j][j+1].head = gimbal_lower_left_o[j]
        gimbal_lower_left_ob[j][j+1].tail = gimbal_lower_left_b[j+1]
        gimbal_lower_left_ob[j][j+1].parent = lower_left_yo[j-1][j-1]

        # gimbal w4w5
#        gimbal_upper_left_ww[j][j+1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+1) +'.gimbal.upper.left')
#        gimbal_upper_left_ww[j][j+1].head = upper_w[j]
#        gimbal_upper_left_ww[j][j+1].tail = upper_w[j+1]
#        gimbal_upper_left_ww[j][j+1].parent = gimbal_upper_left_ww[j-2][j]


        lower_right_by[j][j] = amt.edit_bones.new('b' + str(j) + 'y' + str(j) +'.lower.right')
        lower_right_by[j][j].head = lower_right_b[j]
        lower_right_by[j][j].tail = lower_right_y[j]
        lower_right_by[j][j].parent = lower_right_ob[j-1][j]

        lower_right_yy[j][j+1] = amt.edit_bones.new('y' + str(j) + 'y' + str(j+1) +'.lower.right')
        lower_right_yy[j][j+1].head = lower_right_y[j]
        lower_right_yy[j][j+1].tail = lower_right_y[j+1]
        lower_right_yy[j][j+1].parent = lower_right_by[j][j]

        # gimbal o4b5
        gimbal_lower_right_ob[j][j+1] = amt.edit_bones.new('o' + str(j) + 'b'+ str(j+1) + '.gimbal.lower.right')
        gimbal_lower_right_ob[j][j+1].head = gimbal_lower_right_o[j]
        gimbal_lower_right_ob[j][j+1].tail = gimbal_lower_right_b[j+1]
        gimbal_lower_right_ob[j][j+1].parent = lower_right_yo[j-1][j-1]

        # gimbal w4w5
#        gimbal_upper_right_ww[j][j+1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+1) +'.gimbal.upper.right')
#        gimbal_upper_right_ww[j][j+1].head = upper_w[j]
#        gimbal_upper_right_ww[j][j+1].tail = upper_w[j+1]
#        gimbal_upper_right_ww[j][j+1].parent = gimbal_upper_right_ww[j-2][j]


        j = 5

        # gimbal b5y5
        gimbal_lower_right_by[j][j] = amt.edit_bones.new('b' + str(j) + 'y'+ str(j) + '.gimbal.lower.right')
        gimbal_lower_right_by[j][j].head = gimbal_lower_right_b[j]
        gimbal_lower_right_by[j][j].tail = gimbal_lower_right_y[j]
        gimbal_lower_right_by[j][j].parent = gimbal_lower_right_ob[j-1][j]

        # gimbal y5y6
        gimbal_lower_right_yy[j][j+1] = amt.edit_bones.new('y' + str(j) + 'y'+ str(j+1) + '.gimbal.lower.right')
        gimbal_lower_right_yy[j][j+1].head = gimbal_lower_right_y[j]
        gimbal_lower_right_yy[j][j+1].tail = gimbal_lower_right_y[j+1]
        gimbal_lower_right_yy[j][j+1].parent = gimbal_lower_right_by[j][j]


        # gimbal b5y5
        gimbal_lower_left_by[j][j] = amt.edit_bones.new('b' + str(j) + 'y'+ str(j) + '.gimbal.lower.left')
        gimbal_lower_left_by[j][j].head = gimbal_lower_left_b[j]
        gimbal_lower_left_by[j][j].tail = gimbal_lower_left_y[j]
        gimbal_lower_left_by[j][j].parent = gimbal_lower_left_ob[j-1][j]

        # gimbal y5y6
        gimbal_lower_left_yy[j][j+1] = amt.edit_bones.new('y' + str(j) + 'y'+ str(j+1) + '.gimbal.lower.left')
        gimbal_lower_left_yy[j][j+1].head = gimbal_lower_left_y[j]
        gimbal_lower_left_yy[j][j+1].tail = gimbal_lower_left_y[j+1]
        gimbal_lower_left_yy[j][j+1].parent = gimbal_lower_left_by[j][j]

        # gimbal w5w6
#        gimbal_upper_left_ww[j][j+1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+1) + '.gimbal.upper.left')
#        gimbal_upper_left_ww[j][j+1].head = upper_left_w[j]
#        gimbal_upper_left_ww[j][j+1].tail = upper_left_w[j+1]
#        gimbal_upper_left_ww[j][j+1].parent = gimbal_upper_left_ow[j-3][j]

#        gimbal_upper_right_ww[j][j+1] = amt.edit_bones.new('w' + str(j) + 'w'+ str(j+1) + '.gimbal.upper.right')
#        gimbal_upper_right_ww[j][j+1].head = upper_right_w[j]
#        gimbal_upper_right_ww[j][j+1].tail = upper_right_w[j+1]
#        gimbal_upper_right_ww[j][j+1].parent = gimbal_upper_right_ow[j-3][j]


        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True
        bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        for b in amt.edit_bones:
            b.select = False

        amt.edit_bones["o3b4.lower.left"].select = True
        amt.edit_bones["b4y4.lower.left"].select = True
        amt.edit_bones["y4y5.lower.left"].select = True
        bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_X')

        for b in amt.edit_bones:
            b.select = False

        amt.edit_bones["o3b4.lower.right"].select = True
        amt.edit_bones["b4y4.lower.right"].select = True
        amt.edit_bones["y4y5.lower.right"].select = True
        bpy.ops.armature.calculate_roll(type='GLOBAL_POS_X')


        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint

        j = 1

        cns = rig.pose.bones['y' +str(j) +'a' +str(j+1)].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a'+str(j+1)+'a'+str(j)
        cns.chain_count = 2
        cns.use_stretch = False

        j = 2

        cns = rig.pose.bones['b'+str(j) +'y'+str(j)+'.lower'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y'+str(j)+'o'+str(j)+'.lower'
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['b'+str(j) +'y'+str(j)+'.upper'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y'+str(j)+'o'+str(j)+'.upper.left'
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False
        
        
#        cns = rig.pose.bones['w' +str(j+1) +'w' +str(j)+'.upper.left'].constraints.new('IK')
#        cns.name = 'Ik'
#        cns.target = rig
#        cns.subtarget = 'w' +str(j-1) +'w' +str(j+1)+'.upper.left'
#        cns.chain_count = 1
#        cns.use_stretch = False

#        cns = rig.pose.bones['w' +str(j+1) +'w' +str(j)+'.upper.right'].constraints.new('IK')
#        cns.name = 'Ik'
#        cns.target = rig
#        cns.subtarget = 'w' +str(j-1) +'w' +str(j+1)+'.upper.right'
#        cns.chain_count = 1
#        cns.use_stretch = False

        j = 3

        cns = rig.pose.bones['b'+str(j) +'y'+str(j)+'.upper.left'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y'+str(j)+'o'+str(j)+'.upper'
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['b'+str(j) +'y'+str(j)+'.upper.right'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y'+str(j)+'o'+str(j)+'.upper'
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['o'+str(j) +'b'+str(j+1)+'.gimbal.lower.left'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'b'+str(j+1)+'y'+str(j+1)+'.lower.left'
        cns.pole_target = rig
        cns.pole_subtarget = 'o'+str(j)+'b'+str(j+1)+'.lower.left'
        cns.pole_angle = 0
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['o'+str(j) +'b'+str(j+1)+'.gimbal.lower.right'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'b'+str(j+1)+'y'+str(j+1)+'.lower.right'
        cns.pole_target = rig
        cns.pole_subtarget = 'o'+str(j)+'b'+str(j+1)+'.lower.right'
        cns.pole_angle = math.radians(180)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False


        j = 4

        cns = rig.pose.bones['b'+str(j) +'y'+str(j)+'.lower.right'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y'+str(j+1)+'y'+str(j+2)+'.gimbal.lower.right'
        cns.pole_target = rig
        cns.pole_subtarget = 'b'+str(j+1)+'y'+str(j+1)+'.gimbal.lower.right'
        cns.pole_angle = math.radians(0)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['b'+str(j) +'y'+str(j)+'.lower.left'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'y'+str(j+1)+'y'+str(j+2)+'.gimbal.lower.left'
        cns.pole_target = rig
        cns.pole_subtarget = 'b'+str(j+1)+'y'+str(j+1)+'.gimbal.lower.left'
        cns.pole_angle = math.radians(180)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False
        

#        j = 5
                
#        cns = rig.pose.bones['w'+str(j) +'w'+str(j+1)+'.gimbal.upper.left'].constraints.new('IK')
#        cns.name = 'Ik'
#        cns.target = rig
#        cns.subtarget = 'w'+str(j-2)+'w'+str(j-1)+'.upper.left'
#        cns.pole_target = rig
#        cns.pole_subtarget = 'w'+str(j-4)+'w'+str(j-2)+'.upper.left'
#        cns.pole_angle = math.radians(90)
#        cns.iterations = 500
#        cns.chain_count = 2
#        cns.use_stretch = False

#        cns = rig.pose.bones['w'+str(j) +'w'+str(j+1)+'.gimbal.upper.right'].constraints.new('IK')
#        cns.name = 'Ik'
#        cns.target = rig
#        cns.subtarget = 'w'+str(j-2)+'w'+str(j-1)+'.upper.right'
#        cns.pole_target = rig
#        cns.pole_subtarget = 'w'+str(j-4)+'w'+str(j-2)+'.upper.right'
#        cns.pole_angle = math.radians(90)
#        cns.iterations = 500
#        cns.chain_count = 2
#        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        n = 1

        obj_joint = bpy.data.objects["joint.gold.body.E"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = 'a'+ str(n+1)+'a'+ str(n)+ ".mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = 'a'+ str(n)+'b'+ str(n)+ ".mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = 'y'+ str(n)+'a'+ str(n+1)+".mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = 'a'+ str(n+1)+'o'+ str(n)+".mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".lower.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".lower.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".upper.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".upper.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        n = 2

        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".lower.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".lower.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*(n % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".lower.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".upper.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".upper.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*(n % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".upper.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".upper.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*(n % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".upper.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".upper.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


#        obj_joint = bpy.data.objects["joint.gold.B.R"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "o"+str(n)+"w"+str(n-1)+".upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n-1)+"w"+str(n+1)+".upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+1)+"w"+str(n+2)+".upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w2w5.gimbal
#        obj_joint = bpy.data.objects["joint.gold.g1.y.C.R2"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "o"+str(n)+"w"+str(n+3)+".gimbal.upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w5w6.gimbal
#        obj_joint = bpy.data.objects["joint.silver.g1.z.C.R2"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+3)+"w"+str(n+4)+".gimbal.upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)
        

#        obj_joint = bpy.data.objects["joint.gold.B.L"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "o"+str(n)+"w"+str(n-1)+".upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n-1)+"w"+str(n+1)+".upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+1)+"w"+str(n+2)+".upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w2w5.gimbal
#        obj_joint = bpy.data.objects["joint.gold.g1.y.C.L2"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "o"+str(n)+"w"+str(n+3)+".gimbal.upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w5w6.gimbal
#        obj_joint = bpy.data.objects["joint.silver.g1.z.C.L2"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+3)+"w"+str(n+4)+".gimbal.upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)


        # w2w3.upper
#        obj_joint = bpy.data.objects["joint.gold.B2"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n)+"w"+str(n+1)+".upper.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w2w4.gimbal.upper.left
#        obj_joint = bpy.data.objects["joint.gold.g1.y.C.L"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n)+"w"+str(n+2)+".gimbal.upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w4w5.gimbal.upper.left
#        obj_joint = bpy.data.objects["joint.silver.g1.z.C.L"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+2)+"w"+str(n+3)+".gimbal.upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w3w2.upper.left
#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+1)+"w"+str(n)+".upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w2w1.upper.left
#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n)+"w"+str(n-1)+".upper.left.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w2w4.gimbal.upper.right
#        obj_joint = bpy.data.objects["joint.gold.g1.y.C.R"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n)+"w"+str(n+2)+".gimbal.upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w4w5.gimbal.upper.right
#        obj_joint = bpy.data.objects["joint.silver.g1.z.C.R"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+2)+"w"+str(n+3)+".gimbal.upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w3w2.upper.right
#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n+1)+"w"+str(n)+".upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)

        # w2w1.upper.right
#        obj_joint = bpy.data.objects["joint.cursor"].copy()
#        obj_joint.location = (0.0, 0.0, 0.0)
#        obj_joint.scale = (A, A, A)
#        obj_joint.name = "w"+str(n)+"w"+str(n-1)+".upper.right.mesh." + move + '.' + part +'.' + helicity
#        bpy.context.scene.objects.link(obj_joint)


        n = 3

        obj_joint = bpy.data.objects["joint.gold.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"w"+str(1)+".lower.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.copper.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.B"].copy()
#        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.A"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.B"].copy()
#        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.copper.g1.y.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".gimbal.lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.g1.z.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".gimbal.lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.g1.y.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".gimbal.lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.g1.z.B"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".gimbal.lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".upper.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".upper.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q + Q*(n % 2)*4 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"o"+str(n)+".upper.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2 + Q*(n % 2)*6 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".upper.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        n = 4

        obj_joint = bpy.data.objects["joint.green.leg-left.A"].copy()
#        obj_joint.location = (0.0, 0.0, Q +Z)
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
        
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, Q/2 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.leg-right.A"].copy()
#        obj_joint.location = (0.0, 0.0, Q +Z)
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, Q/2 +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".gimbal.lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
 
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "o"+str(n)+"b"+str(n+1)+".gimbal.lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        n = 5

        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".gimbal.lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
 
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b"+str(n)+"y"+str(n)+".gimbal.lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".gimbal.lower.left.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)
 
        obj_joint = bpy.data.objects["joint.cursor"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y"+str(n)+"y"+str(n+1)+".gimbal.lower.right.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True

        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


    # Parent set arms to body        
    def setParent(self, helicity, move, rig, 
            arm_left_loc, arm_left_rot, arm_left,
            arm_right_loc, arm_right_rot, arm_right):

        bpy.ops.object.mode_set(mode='OBJECT')
        bpy.context.scene.frame_current = 0

        # arm left
        bpy.ops.object.select_all(action='DESELECT')
        rig.select = True
        bpy.context.scene.objects.active = rig

        bpy.ops.object.editmode_toggle()

##        parent_bone = 'o2b3.upper.left' # choose the bone name which you want to be the parent
#        parent_bone = 'o2w5.gimbal.upper.left' # choose the bone name which you want to be the parent
        parent_bone = 'o2b3.upper.left' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        arm_left.rig.select = True

        rig.select = True
        bpy.context.scene.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
        # arm left end

        # arm right
        bpy.ops.object.select_all(action='DESELECT') #deselect all objects
        rig.select = True
        bpy.context.scene.objects.active = rig

        bpy.ops.object.editmode_toggle()

##        parent_bone = 'o2b3.upper.right' # choose the bone name which you want to be the parent
#        parent_bone = 'o2w5.gimbal.upper.right' # choose the bone name which you want to be the parent
        parent_bone = 'o2b3.upper.right' # choose the bone name which you want to be the parent
        
        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        arm_right.rig.select = True

        rig.select = True
        bpy.context.scene.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)
        # arm right end

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        # arms position
        arm_left.rig.location = arm_left_loc
        arm_left.rig.rotation_euler = arm_left_rot

        arm_right.rig.location = arm_right_loc
        arm_right.rig.rotation_euler = arm_right_rot

        ### grab the long pole with the right hand
        arm_left.rig.select = True

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        # IK constraint y4 -> right hand
        cns = arm_left.rig.pose.bones['y4w1'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = arm_right.rig
        cns.subtarget = 'y3y4'
        cns.head_tail = 1

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        arm_right.rig.select = True

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')

        # IK constraint y5 -> right hand
        cns = arm_right.rig.pose.bones['y4w1'].constraints.new('DAMPED_TRACK')
        cns.name = 'Damped Track'
        cns.target = arm_left.rig
        cns.subtarget = 'y3y4'
        cns.head_tail = 1

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects


        
class LeftArm(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J+1)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        
        self.w = [0 for i in range(self.J)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w):

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((5.26951, -4.03022, 0), 'XYZ')
        print ("y2 =", y[2])

        b[2] = mathutils.Euler((5.83868, -3.28886, 0), 'XYZ')
        print ("b2 =", b[2])

        o[2] = mathutils.Euler((4.67721, -3.49894, 0), 'XYZ')
        print ("o2 =", o[2])

        y[3] = mathutils.Euler((10.5083, -5.66167, 0), 'XYZ')
        print ("y3 =", y[3])

        b[3] = mathutils.Euler((9.90252, -5.86217, 0), 'XYZ')
        print ("b3 =", b[3])
        
        o[3] = mathutils.Euler((10.5471, -5.37426, 0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler((12.4707, -5.6589, 0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler((12.4708, -5.66167, 0), 'XYZ')
        print ("y5 =", y[5])
        
        w[1] = mathutils.Euler((12.4707, -5.6589, 68.3593), 'XYZ')
        print ("w1 =", w[1])
        
        w[2] = mathutils.Euler((12.4416, -5.49697, 68.3593), 'XYZ')
        print ("w2 =", w[2])
                
        w[3] = mathutils.Euler((12.4708, -5.66167, 68.3593), 'XYZ')
        print ("w3 =", w[3])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J+1)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        yw = [[0 for i in range(self.J)] for j in range(self.J+1)] # Link γ(i) - ω(j)
        ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link ω(i) - ω(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-2):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]

        yw[4][1] = amt.edit_bones.new('y4w1')
        yw[4][1].head = y[4]
        yw[4][1].tail = w[1]
        yw[4][1].parent = yy[3][4]

        ww[1][2] = amt.edit_bones.new('w1w2')
        ww[1][2].head = w[1]
        ww[1][2].tail = w[2]
        ww[1][2].parent = yw[4][1]

        yy[3][5] = amt.edit_bones.new('y3y5.gimbal')
        yy[3][5].head = y[3]
        yy[3][5].tail = y[5]
        yy[3][5].parent = by[3][3]

        yw[5][3] = amt.edit_bones.new('y5w3.gimbal')
        yw[5][3].head = y[5]
        yw[5][3].tail = w[3]
        yw[5][3].parent = yy[3][5]

        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        cns = rig.pose.bones['y5w3.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'w1w2'
        cns.pole_target = rig
        cns.pole_subtarget = 'y4w1'
        cns.pole_angle = math.radians(90)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.arm-left.008"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.002"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(3+4)+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1+4)+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, -Q*4 + Q*(n % 2)*8 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y4y5.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4w1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "w1w2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.green.y4y6.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y5.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y6w3.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y5w3.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class RightArm(Formula):

    J = 5 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J+1)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        
        self.w = [0 for i in range(self.J)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w):

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((5.26951, -4.03022, 0), 'XYZ')
        print ("y2 =", y[2])

        b[2] = mathutils.Euler((5.83868, -3.28886, 0), 'XYZ')
        print ("b2 =", b[2])

        o[2] = mathutils.Euler((4.67721, -3.49894, 0), 'XYZ')
        print ("o2 =", o[2])

        y[3] = mathutils.Euler((10.5083, -5.66167, 0), 'XYZ')
        print ("y3 =", y[3])

        b[3] = mathutils.Euler((9.90252, -5.86217, 0), 'XYZ')
        print ("b3 =", b[3])
        
        o[3] = mathutils.Euler((10.5471, -5.37426, 0), 'XYZ')
        print ("o3 =", o[3])
        
        y[4] = mathutils.Euler((12.4707, -5.6589, 0), 'XYZ')
        print ("y4 =", y[4])

        y[5] = mathutils.Euler((12.4708, -5.66167, 0), 'XYZ')
        print ("y5 =", y[5])
        
        w[1] = mathutils.Euler((12.4707, -5.6589, -1.0), 'XYZ')
        print ("w1 =", w[1])
        
        w[2] = mathutils.Euler((12.4416, -5.49697, -1.0), 'XYZ')
        print ("w2 =", w[2])
                
        w[3] = mathutils.Euler((12.4708, -5.66167, -1.0), 'XYZ')
        print ("w3 =", w[3])

    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J+1)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        yw = [[0 for i in range(self.J)] for j in range(self.J+1)] # Link γ(i) - ω(j)
        ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link ω(i) - ω(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 1):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-2):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]

        yw[4][1] = amt.edit_bones.new('y4w1')
        yw[4][1].head = y[4]
        yw[4][1].tail = w[1]
        yw[4][1].parent = yy[3][4]

        ww[1][2] = amt.edit_bones.new('w1w2')
        ww[1][2].head = w[1]
        ww[1][2].tail = w[2]
        ww[1][2].parent = yw[4][1]

        yy[3][5] = amt.edit_bones.new('y3y5.gimbal')
        yy[3][5].head = y[3]
        yy[3][5].tail = y[5]
        yy[3][5].parent = by[3][3]

        yw[5][3] = amt.edit_bones.new('y5w3.gimbal')
        yw[5][3].head = y[5]
        yw[5][3].tail = w[3]
        yw[5][3].parent = yy[3][5]

        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 1):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False

        cns = rig.pose.bones['y5w3.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'w1w2'
        cns.pole_target = rig
        cns.pole_subtarget = 'y4w1'
        cns.pole_angle = math.radians(90)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.arm-right.008"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.002"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(3+4)+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*(1+4)+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for n in range(1, J - 1):

            if n <= (J-2):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-3):

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)


            if n <= (J-3):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, -Q*4 + Q*(n % 2)*8 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y3y4.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y4w1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "w1w2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y3y5.gimbal.000"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3y5.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y5w3.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y5w3.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


class LeftLeg(Formula):

    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end,
        leg_left_loc, leg_left_rot,
        leg_right_loc, leg_right_rot, leg_right,
        pitch_loc, pitch_rot, pitch):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        # leg_left
        self.leg_left_loc = leg_left_loc
        self.leg_left_rot = leg_left_rot

        # leg_right
        self.leg_right_loc = leg_right_loc
        self.leg_right_rot = leg_right_rot
        
        self.leg_right = leg_right

        # pitch
        self.pitch_loc = pitch_loc
        self.pitch_rot = pitch_rot

        self.pitch = pitch
        
        # body
        self.body = body
        
        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        
        self.w = [0 for i in range(self.J)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)

        # Parent set pitch and right leg to left leg
        self.setParent(self.helicity, self.move, self.rig, 
            self.leg_left_loc, self.leg_left_rot,
            self.leg_right_loc, self.leg_right_rot, self.leg_right,
            self.pitch_loc, self.pitch_rot, self.pitch)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w):

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((5.64394, -7.71944, 0), 'XYZ')
        print ("y2 =", y[2])

        b[2] = mathutils.Euler((6.96819, -6.39353, 0), 'XYZ')
        print ("b2 =", b[2])

        o[2] = mathutils.Euler((7.57679, -7.71912, 0), 'XYZ')
        print ("o2 =", o[2])

        y[3] = mathutils.Euler((5.64394, -17.9947, 0), 'XYZ')
        print ("y3 =", y[3])
        
        o[4] = mathutils.Euler((3.89305, -26.8512, 0), 'XYZ')
        print ("o4 =", o[4])

        o[3] = mathutils.Euler((-1.02857, -20.6204, 0), 'XYZ')
        print ("o3 =", o[3])

        b[4] = mathutils.Euler((12.94517, -7.71944, 0), 'XYZ')
        print ("b4 =", b[4])

        b[3] = mathutils.Euler((5.64394, -7.71944, -7.30119), 'XYZ')
        print ("b3 =", b[3])
        
        w[1] = mathutils.Euler((5.64394, -5.67138, -7.30119), 'XYZ')
        print ("w1 =", w[1])
        
        w[2] = mathutils.Euler((5.64394, -5.47138, -7.30119), 'XYZ')
        print ("w2 =", w[2])

        w[3] = mathutils.Euler((12.94517, -5.67138, 0), 'XYZ')
        print ("w3 =", w[3])

        b[6] = mathutils.Euler((1.7675, -A, 0), 'XYZ')
        print ("b6 =", b[6])

        b[5] = mathutils.Euler((-A, -A, -2.43247), 'XYZ')
        print ("b5 =", b[5])

        w[4] = mathutils.Euler((-A, A, -2.43247), 'XYZ')
        print ("w4 =", w[4])

        w[5] = mathutils.Euler((-A, 0.835105, -2.43247), 'XYZ')
        print ("w5 =", w[5])

        w[6] = mathutils.Euler((1.7675, A, 0), 'XYZ')
        print ("w6 =", w[6])


    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        yb = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - β(j)
        bw = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - ω(j)
        ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link ω(i) - ω(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 4):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J-5):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]

        yo[3][3] = amt.edit_bones.new('y3o3')
        yo[3][3].head = y[3]
        yo[3][3].tail = o[3]
        yo[3][3].parent = yy[2][3]
        yo[3][3].use_inherit_rotation = False

        yo[3][4] = amt.edit_bones.new('y3o4')
        yo[3][4].head = y[3]
        yo[3][4].tail = o[4]
        yo[3][4].parent = yy[2][3]
        yo[3][4].use_inherit_rotation = False

        yb[2][3] = amt.edit_bones.new('y2b3')
        yb[2][3].head = y[2]
        yb[2][3].tail = b[3]
        yb[2][3].parent = yy[1][2]

        bw[3][1] = amt.edit_bones.new('b3w1')
        bw[3][1].head = b[3]
        bw[3][1].tail = w[1]
        bw[3][1].parent = yb[2][3]

        ww[1][2] = amt.edit_bones.new('w1w2')
        ww[1][2].head = w[1]
        ww[1][2].tail = w[2]
        ww[1][2].parent = bw[3][1]

        yb[2][4] = amt.edit_bones.new('y2b4.gimbal')
        yb[2][4].head = y[2]
        yb[2][4].tail = b[4]
        yb[2][4].parent = yy[1][2]

        bw[4][3] = amt.edit_bones.new('b4w3.gimbal')
        bw[4][3].head = b[4]
        bw[4][3].tail = w[3]
        bw[4][3].parent = yb[2][4]

        yb[1][5] = amt.edit_bones.new('y1b5')
        yb[1][5].head = y[1]
        yb[1][5].tail = b[5]
        yb[1][5].parent = by[1][1]

        bw[5][4] = amt.edit_bones.new('b5w4')
        bw[5][4].head = b[5]
        bw[5][4].tail = w[4]
        bw[5][4].parent = yb[1][5]

        ww[4][5] = amt.edit_bones.new('w4w5')
        ww[4][5].head = w[4]
        ww[4][5].tail = w[5]
        ww[4][5].parent = bw[5][4]

        yb[1][6] = amt.edit_bones.new('y1b6.gimbal')
        yb[1][6].head = y[1]
        yb[1][6].tail = b[6]
        yb[1][6].parent = by[1][1]

        bw[6][6] = amt.edit_bones.new('b6w6.gimbal')
        bw[6][6].head = b[6]
        bw[6][6].tail = w[6]
        bw[6][6].parent = yb[1][6]

        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 4):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False
        
        cns = rig.pose.bones['b4w3.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'w1w2'
        cns.pole_target = rig
        cns.pole_subtarget = 'b3w1'
        cns.pole_angle = math.radians(0)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False
        
        cns = rig.pose.bones['b6w6.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'w4w5'
        cns.pole_target = rig
        cns.pole_subtarget = 'b5w4'
        cns.pole_angle = math.radians(0)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')
        

    # Parent set pitch and right leg to left leg
    def setParent(self, helicity, move, rig, 
            leg_left_loc, leg_left_rot,
            leg_right_loc, leg_right_rot, leg_right,
            pitch_loc, pitch_rot, pitch):

        # leg left position
        rig.location = leg_left_loc
        rig.rotation_euler = leg_left_rot

        # leg right position
        leg_right.rig.location = leg_right_loc
        leg_right.rig.rotation_euler = leg_right_rot

        # pitch position
        pitch.rig.location = pitch_loc
        pitch.rig.rotation_euler = pitch_rot

        # pitch to left leg
        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.context.scene.frame_current = 0

        bpy.ops.object.select_all(action='DESELECT')
        rig.select = True
        bpy.context.scene.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3o4' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        pitch.rig.select = True

        rig.select = True
        bpy.context.scene.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects
        # end
        
        rig.select = True
        bpy.context.scene.objects.active = rig

        bpy.ops.object.editmode_toggle()

        parent_bone = 'y3o3' # choose the bone name which you want to be the parent

        rig.data.edit_bones.active = rig.data.edit_bones[parent_bone]

        bpy.ops.object.mode_set(mode='OBJECT')

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects

        leg_right.rig.select = True

        rig.select = True
        bpy.context.scene.objects.active = rig    #the active object will be the parent of all selected object

        bpy.ops.object.parent_set(type='BONE', keep_transform=True)

        bpy.ops.object.select_all(action='DESELECT') #deselect all objects


    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for n in range(1, J - 3):

            if n <= (J-5):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-6):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, -Q*4 + Q*(n % 2)*8 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-6):

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3o3.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y3o4.leg-left.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3o4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.copper.y2b3.leg-left.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y2b3.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b3w1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "w1w2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y3y5.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y2b4.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.b4w3.gimbal.leg-left.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b4w3.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.gold.y1b5.leg-left.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1b5.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b5w4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "w4w5.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y3y5.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1b6.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.b6w6.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b6w6.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')



class RightLeg(Formula):

    J = 7 #joint number

    # Overriding
    def __init__(self, P, A, move, part, helicity, start, end):

        global interval
        global frame_start
        global frame_end

        self.interval = interval
        self.frame_start = frame_start
        self.frame_end = frame_end

        # pivot factor
        self.P = P

        # scale factor
        self.A = A 

        # name
        self.move = move

        # element
        self.part = part

        # element helicity
        self.helicity = helicity

        self.start = start
        self.end = end

        bpy.ops.object.mode_set(mode='OBJECT')

        # Create armature and object
        self.amt = bpy.data.armatures.new(move + '.' + part + '.' + helicity + '.data')
        self.rig = bpy.data.objects.new(move + '.' + part + '.' + helicity, self.amt)

        # Joints
        self.a = [0 for i in range(4)] # Joint α
        self.b = [0 for i in range(self.J)] # Joint β
        self.y = [0 for i in range(self.J)] # Joint γ
        self.o = [0 for i in range(self.J)] # Joint δ
        
        self.w = [0 for i in range(self.J)] # Joint ω

        # Configuration Movement
        self.configMovement(self.P, self.A, self.J, self.a, self.b, self.y, self.o, self.w)

        # Construction Movement
        self.constructMovement(self.J, self.helicity, self.amt, self.rig, self.a, self.b, self.y, self.o, self.w)

        # Construction Rotation
        self.configRotation(self.rig, self.interval, self.frame_start, self.frame_end, self.start, self.end)

        # Configuration Linkage
        self.configLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

        # Construction Linkage
        self.constructLink(self.A, self.J, self.helicity, self.rig, self.move, self.part)

    # Overriding Configuration Movement
    def configMovement(self, P, A, J, a, b, y, o, w):

        a[1] = mathutils.Euler((P, A, 0), 'XYZ')
        print ("a1 =", a[1])

        a[2] = mathutils.Euler((A, -A, 0), 'XYZ')
        print ("a2 =", a[2])

        b[1] = mathutils.Euler((-A, A, 0), 'XYZ')
        print ("b1 =", b[1])

        o[1] = mathutils.Euler((A, A, 0), 'XYZ')
        print ("o1 =", o[1])

        B = A * 2 * sqrt (2)
        C = B + (B * sqrt (2))
        D = C * sqrt (2)
        E = C + D

        y[1] = mathutils.Euler((-A, -A, 0), 'XYZ')
        print ("y1 =", y[1])
        
        y[2] = mathutils.Euler((5.68545, -7.44271, 0), 'XYZ')
        print ("y2 =", y[2])

        b[2] = mathutils.Euler((6.95751, -6.17062, 0), 'XYZ')
        print ("b2 =", b[2])

        o[2] = mathutils.Euler((7.53988, -7.37879, 0), 'XYZ')
        print ("o2 =", o[2])

        y[3] = mathutils.Euler((7.73628, -17.1943, 0), 'XYZ')
        print ("y3 =", y[3])


        b[4] = mathutils.Euler((11.3434, -7.44271, 0), 'XYZ')
        print ("b4 =", b[4])

        b[3] = mathutils.Euler((5.68546, -7.44271, -5.65991), 'XYZ')
        print ("b3 =", b[3])
        
        w[1] = mathutils.Euler((5.68546, -5.67138, -8.65991), 'XYZ')
        print ("w1 =", w[1])
        
        w[2] = mathutils.Euler((5.68546, -5.47138, -8.65991), 'XYZ')
        print ("w2 =", w[2])
        
        w[3] = mathutils.Euler((14.3434, -5.67138, 0), 'XYZ')
        print ("w3 =", w[3])


        b[6] = mathutils.Euler((10.1687, -17.1943, 0), 'XYZ')
        print ("b6 =", b[6])

        b[5] = mathutils.Euler((7.73628, -17.1943, -2.43205), 'XYZ')
        print ("b5 =", b[5])
        
        w[4] = mathutils.Euler((7.73628, -15.42297, -5.43205), 'XYZ')
        print ("w4 =", w[4])
        
        w[5] = mathutils.Euler((7.73628, -15.22297, -5.43205), 'XYZ')
        print ("w5 =", w[5])
        
        w[6] = mathutils.Euler((13.1687, -15.42297, 0), 'XYZ')
        print ("w6 =", w[6])


    def constructMovement(self, J, helicity, amt, rig, a, b, y, o, w):

        # Linkages
        aa = [[0 for i in range(4)] for j in range(4)] # Link α(i) - α(j)
        ab = [[0 for i in range(4)] for j in range(4)] # Link α(i) - β(j)
        ya = [[0 for i in range(4)] for j in range(4)] # Link γ(i) - α(j)
        ao = [[0 for i in range(4)] for j in range(4)] # Link α(i) - δ(j)
        ob = [[0 for i in range(self.J)] for j in range(self.J)] # Link δ(i) - β(j)
        yy = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - γ(j)
        by = [[0 for i in range(self.J)] for j in range(self.J)] # Link β(i) - γ(j)
        yo = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - δ(j)
        yb = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - β(j)
        bw = [[0 for i in range(self.J)] for j in range(self.J)] # Link γ(i) - ω(j)
        ww = [[0 for i in range(self.J)] for j in range(self.J)] # Link ω(i) - ω(j)

        rig.location = mathutils.Euler((0.0, 0.0, 0.0), 'XYZ')
        rig.show_x_ray = True
        amt.show_names = True
        amt.draw_type = 'STICK'
#        amt.draw_type = 'BBONE'

        # Link object to scene
        scn = bpy.context.scene
        scn.objects.link(rig)
        scn.objects.active = rig
        scn.update()

        # Edit
        bpy.ops.object.editmode_toggle()

        # Construction Linkage
        aa[2][1] = amt.edit_bones.new('a2a1')
        aa[2][1].head = a[2]
        aa[2][1].tail = a[1]
        
        ab[1][1] = amt.edit_bones.new('a1b1')
        ab[1][1].head = a[1]
        ab[1][1].tail = b[1]
        ab[1][1].parent = aa[2][1]
 
        by[1][1] = amt.edit_bones.new('b1y1')
        by[1][1].head = b[1]
        by[1][1].tail = y[1]
        by[1][1].parent = ab[1][1]
        by[1][1].use_inherit_rotation = False

        ya[1][2] = amt.edit_bones.new('y1a2')
        ya[1][2].head = y[1]
        ya[1][2].tail = a[2]
        ya[1][2].parent = by[1][1]

        ao[2][1] = amt.edit_bones.new('a2o1')
        ao[2][1].head = a[2]
        ao[2][1].tail = o[1]
        ao[2][1].parent = ya[1][2]

        ob[1][2] = amt.edit_bones.new('o1b2')
        ob[1][2].head = o[1]
        ob[1][2].tail = b[2]
        ob[1][2].parent = ao[2][1]
        
        yy[1][2] = amt.edit_bones.new('y1y2')
        yy[1][2].head = y[1]
        yy[1][2].tail = y[2]
        yy[1][2].parent = by[1][1]

        for j in range(2, J - 4):

            by[j][j] = amt.edit_bones.new('b'+ str(j) + 'y'+ str(j))
            by[j][j].head = b[j]
            by[j][j].tail = y[j]
            by[j][j].parent = ob[j-1][j]

            yo[j][j] = amt.edit_bones.new('y'+ str(j) + 'o'+ str(j))
            yo[j][j].head = y[j]
            yo[j][j].tail = o[j]
            yo[j][j].parent = yy[j-1][j]

            yy[j][j+1] = amt.edit_bones.new('y'+ str(j) + 'y'+ str(j+1))
            yy[j][j+1].head = y[j]
            yy[j][j+1].tail = y[j+1]
            yy[j][j+1].parent = by[j][j]

            if j < (J - 5):
                ob[j][j+1] = amt.edit_bones.new('o'+ str(j) + 'b'+ str(j+1))
                ob[j][j+1].head = o[j]
                ob[j][j+1].tail = b[j+1]
                ob[j][j+1].parent = yo[j][j]

        yb[2][3] = amt.edit_bones.new('y2b3')
        yb[2][3].head = y[2]
        yb[2][3].tail = b[3]
        yb[2][3].parent = yy[1][2]

        bw[3][1] = amt.edit_bones.new('b3w1')
        bw[3][1].head = b[3]
        bw[3][1].tail = w[1]
        bw[3][1].parent = yb[2][3]

        ww[1][2] = amt.edit_bones.new('w1w2')
        ww[1][2].head = w[1]
        ww[1][2].tail = w[2]
        ww[1][2].parent = bw[3][1]

        yb[2][4] = amt.edit_bones.new('y2b4.gimbal')
        yb[2][4].head = y[2]
        yb[2][4].tail = b[4]
        yb[2][4].parent = yy[1][2]

        bw[4][3] = amt.edit_bones.new('b4w3.gimbal')
        bw[4][3].head = b[4]
        bw[4][3].tail = w[3]
        bw[4][3].parent = yb[2][4]

        yb[3][5] = amt.edit_bones.new('y3b5')
        yb[3][5].head = y[3]
        yb[3][5].tail = b[5]
        yb[3][5].parent = yy[2][3]

        bw[5][4] = amt.edit_bones.new('b5w4')
        bw[5][4].head = b[5]
        bw[5][4].tail = w[4]
        bw[5][4].parent = yb[3][5]

        ww[4][5] = amt.edit_bones.new('w4w5')
        ww[4][5].head = w[4]
        ww[4][5].tail = w[5]
        ww[4][5].parent = bw[5][4]

        yb[3][6] = amt.edit_bones.new('y3b6.gimbal')
        yb[3][6].head = y[3]
        yb[3][6].tail = b[6]
        yb[3][6].parent = yy[2][3]

        bw[6][6] = amt.edit_bones.new('b6w6.gimbal')
        bw[6][6].head = b[6]
        bw[6][6].tail = w[6]
        bw[6][6].parent = yb[3][6]

        # all bones select
        #bpy.ops.pose.select_all(action="SELECT")
        for b in amt.edit_bones:
            b.select = True

        if helicity == 'right':
            bpy.ops.armature.calculate_roll(type='GLOBAL_POS_Z')
        else:
            bpy.ops.armature.calculate_roll(type='GLOBAL_NEG_Z')

        # Bone constraints. Armature must be in pose mode.
        bpy.ops.object.mode_set(mode='POSE')
 
        # IK constraint
        cns = rig.pose.bones['y1a2'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'a2a1'
        cns.chain_count = 2
        cns.use_stretch = False

        for j in range(2, J - 4):
            cns = rig.pose.bones['b'+str(j) +'y'+str(j)].constraints.new('IK')
            cns.name = 'Ik'
            cns.target = rig
            cns.subtarget = 'y'+str(j)+'o'+str(j)
            cns.iterations = 500
            cns.chain_count = 2
            cns.use_stretch = False
        
        cns = rig.pose.bones['b4w3.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'w1w2'
        cns.pole_target = rig
        cns.pole_subtarget = 'b3w1'
        cns.pole_angle = math.radians(0)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        cns = rig.pose.bones['b6w6.gimbal'].constraints.new('IK')
        cns.name = 'Ik'
        cns.target = rig
        cns.subtarget = 'w4w5'
        cns.pole_target = rig
        cns.pole_subtarget = 'b5w4'
        cns.pole_angle = math.radians(0)
        cns.iterations = 500
        cns.chain_count = 2
        cns.use_stretch = False

        bpy.ops.object.mode_set(mode='OBJECT')

    def configLink(self, A, J, helicity, rig, move, part):

        bpy.ops.object.mode_set(mode='OBJECT')
    
        Q = (0.18648+0.146446)*A
    #   Z = -Q*2
        Z = 0.0

        obj_joint = bpy.data.objects["joint.gold.leg-right.000"].copy()
        obj_joint.location = (0.0, 0.0, -Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2a1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.silver.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y1a2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*3+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a2o1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.001"].copy()
        obj_joint.location = (0.0, 0.0, -Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "a1b1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        for n in range(1, J - 3):

            if n <= (J-5):

                # Pattern 2 of by
                obj_joint = bpy.data.objects["joint.green.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "b"+str(n)+"y"+str(n)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-6):

                # Pattern 2 of yy
                obj_joint = bpy.data.objects["joint.gold.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, +Q*(1 - (n % 2))*2+Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n)+"y"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-6):

                # Pattern 1 of ob
                obj_joint = bpy.data.objects["joint.blue.00"+str(1 + (n+1) % 2)].copy()
                obj_joint.location = (0.0, 0.0, -Q*4 + Q*(n % 2)*8 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "o"+str(n)+"b"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

            if n <= (J-6):

                # Pattern 2 of yo
                obj_joint = bpy.data.objects["joint.copper.001"].copy()
                obj_joint.location = (0.0, 0.0, -Q + Q*((n+1) % 2)*4 +Z)
                obj_joint.scale = (A, A, A)
                obj_joint.name = "y"+str(n+1)+"o"+str(n+1)+".mesh." + move + '.' + part +'.' + helicity
                bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y2y3.leg-right.001"].copy()
        obj_joint.location = (0.0, 0.0, +Q*2+Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y2y3.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.copper.y2b3.leg-right.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y2b3.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b3w1.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "w1w2.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y3y5.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y2b4.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.b4w3.gimbal.gimbal.leg-right.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b4w3.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        obj_joint = bpy.data.objects["joint.gold.y3b5.leg-right.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3b5.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b5w4.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["cursor.001"].copy()
        obj_joint.location = (0.0, 0.0, 0.0)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "w4w5.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.gold.y3y5.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "y3b6.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)

        obj_joint = bpy.data.objects["joint.blue.b6w6.gimbal.001"].copy()
        obj_joint.location = (0.0, 0.0, +Z)
        obj_joint.scale = (A, A, A)
        obj_joint.name = "b6w6.gimbal.mesh." + move + '.' + part +'.' + helicity
        bpy.context.scene.objects.link(obj_joint)


        for ob in context.scene.objects:
            if "mesh" in ob.name:
                ob.select = True
    
        bpy.ops.object.make_single_user(type='SELECTED_OBJECTS', object=True, obdata=True, material=True, texture=True, animation=True)
        bpy.context.scene.cursor_location = (0.0, 0.0, 0.0)
        bpy.ops.object.origin_set(type='ORIGIN_CURSOR')


def formula():

# pivot factor
    P = 0

# scale factor
    A = 1
    
# name
    move = 'formula'

# element
    part = 'universe'

# left or right
    helicity = 'left'

    start = 0
    end = start+360

    formula = Formula(P, A, move, part, helicity, start, end)


def arms():

# scale factor
    A = 0.380

# pivot factor
#    P = 0.010708
    P = -(A*0.75)

# name
    move = 'kungfu'

# arm element
    part = 'arm-left'

# left arm element
    helicity = 'left'

    start = -10.4964
    end = start+360

    global arm_left
    arm_left = LeftArm(P, A, move, part, helicity, start, end)

# arm element
    part = 'arm-right'

# right arm element
    helicity = 'right'

    start = -190.4964
    end = start-360

    global arm_right
    arm_right = RightArm(P, A, move, part, helicity, start, end)


def legs():

# name
    move = 'kungfu'

# arm element
    part = 'leg-right'

# scale factor
    A = 0.638694

# pivot factor
    P = -0.02853
#   P = 0

## right leg element
    helicity = 'right'

    start = -585.491
    end = -585.491

    global leg_right

    leg_right = RightLeg(P, A, move, part, helicity, start, end)

    leg_right_loc = (8.88082, 1.22518, 22.398)
    leg_right_rot = mathutils.Euler((math.radians(-90.0), math.radians(173.618), math.radians(0.0)), 'XYZ')

# arm element
    part = 'leg-left'

# scale factor
    A = 0.664895

# pivot factor
    P = -0.030131
#   P = 0

# left leg element
    helicity = 'right'

    start = 404.509
    end = 404.509

    global pitch
    
    pitch_loc = (11.7981, 1.49764, 26.9466)
    pitch_rot = mathutils.Euler((math.radians(90.0), math.radians(29.4707), math.radians(-90)), 'XYZ')

    global leg_left

    leg_left_loc = (14.053, 5.91232, 1.8578)
    leg_left_rot = mathutils.Euler((math.radians(-90.0), math.radians(-13.2686), math.radians(0.0)), 'XYZ')

    leg_left = LeftLeg(P, A, move, part, helicity, start, end,
        leg_left_loc, leg_left_rot,
        leg_right_loc, leg_right_rot, leg_right,
        pitch_loc, pitch_rot, pitch)

    global body

    bpy.ops.object.mode_set(mode='OBJECT')

    body.rig.select = True

    # Bone constraints. Armature must be in pose mode.
    bpy.ops.object.mode_set(mode='POSE')

    # IK constraint 
    cns = body.rig.pose.bones['o4b5.gimbal.lower.right'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = leg_right.rig
    cns.subtarget = 'y2b3'
    cns.head_tail = 1
        
    cns = body.rig.pose.bones['b5y5.gimbal.lower.right'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = leg_right.rig
    cns.subtarget = 'y3b5'
    cns.head_tail = 1

    cns = body.rig.pose.bones['o4b5.gimbal.lower.left'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = leg_left.rig
    cns.subtarget = 'y2b3'
    cns.head_tail = 1

    cns = body.rig.pose.bones['b5y5.gimbal.lower.left'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = leg_left.rig
    cns.subtarget = 'y1b5'
    cns.head_tail = 1

    bpy.ops.object.mode_set(mode='OBJECT')
    
    leg_right.rig.select = True
    
    # Bone constraints. Armature must be in pose mode.
    bpy.ops.object.mode_set(mode='POSE')

    # IK constraint 
    cns = leg_right.rig.pose.bones['b3w1'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = body.rig
    cns.subtarget = 'y3o3.lower.right'
    cns.head_tail = 1

    cns = leg_right.rig.pose.bones['b5w4'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = body.rig
    cns.subtarget = 'b5y5.gimbal.lower.right'
    cns.head_tail = 0

    bpy.ops.object.mode_set(mode='OBJECT')

    leg_left.rig.select = True
    
    # Bone constraints. Armature must be in pose mode.
    bpy.ops.object.mode_set(mode='POSE')
    
    cns = leg_left.rig.pose.bones['b3w1'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = body.rig
    cns.subtarget = 'y3o3.lower.left'
    cns.head_tail = 1
    
    cns = leg_left.rig.pose.bones['b5w4'].constraints.new('DAMPED_TRACK')
    cns.name = 'Damped Track'
    cns.target = body.rig
    cns.subtarget = 'b5y5.gimbal.lower.left'
    cns.head_tail = 0
    
    bpy.ops.object.mode_set(mode='OBJECT')


def body():

# scale factor
    A = 1
    
# pivot factor
    P = -(A * 0.724843)

# name
    move = 'kungfu'

# arm element
    part = 'body'

# helicity of element
    helicity = 'right'

    start = 132.259
    end = start + 360

#    start = 295
#    end = 632.6244

    global arm_left
    global arm_right

    arm_left_loc = (2.02582, 3.69302, -0.543891)
    arm_left_rot = mathutils.Euler((math.radians(20.4709), math.radians(-164.934), math.radians(77.5203)), 'XYZ')

    arm_right_loc = (-5.16138, 2.80318, 0.21855)
    arm_right_rot = mathutils.Euler((math.radians(-374.392), math.radians(-17.0148), math.radians(295.586)), 'XYZ')

    global body

    body = Body(P, A, move, part, helicity, start, end, 
        arm_left_loc, arm_left_rot, arm_left,
        arm_right_loc, arm_right_rot, arm_right)


def pitch():

# scale factor
    A = 2.0

# pivot factor
    P = -1.685
    
# name
    move = 'kungfu'

# arm element
    part = 'pitch'

# helicity of element
    helicity = 'left'
    
    start = 0.008209
    end = start + 360

    global body

    body_loc = (-0.829043, 2.38647, -2.69095)
    body_rot = mathutils.Euler((math.radians(-83.863), math.radians(87.2567), math.radians(-51.9298)), 'XYZ')

    global pitch
    
    pitch = Pitch(P, A, move, part, helicity, start, end,
        body_loc, body_rot, body)


def main(origin):
    
    global interval
    global frame_start
    global frame_end

    frame_start = 0

    frame_end = 96
    
    interval = frame_end - frame_start
    
#    formula()
    arms()
    body() #roll
    pitch()
    legs()

if __name__ == "__main__":
    # renaming of corrada objects
#    for ob in context.scene.objects:
#        if "joint_" in ob.name:
#            ob.name = ob.name.replace("_", ".")
            
    main((0,0,0))
